[{"title":"我的30岁","url":"/2025/03/24/我的30岁/","content":"这是我的30岁记录\n1994年出生在河南开封的某一个村庄里面，父母和爷爷奶奶都是农民，小时候家里穷，\n<!-- more -->\n刚有个小妹妹又赶上计划生育，导致家里一贫如洗，生过妹妹之后，父母便考虑种菜，种植蘑菇，补贴家用，也正是当时父母的辛勤劳作才让我家盖了房子，一出生因为是男孩感觉在格外受到照顾，刚盖完房子经济更紧张了 我也要上学了，幼儿园半学期要100元，我们那个时候连50元都拿不出来，后来没办法过年的时候爸妈把家里养的猪卖了"},{"title":"记录搭建github二级域名博客遇到的问题","url":"/2025/03/24/记录搭建github二级域名博客遇到的问题/","content":"\n\n## 1.推送失败本地预览没有问题 `Deployer not found: git`\n**提示`Deployer not found: git`**\n\n原因1、没有安装插件 该插件可以将本地代码 `build` 之后提交到你指定的 `github` 仓库分支\n\n<!-- more -->\n```\n  npm install hexo-deployer-git --save\n```\n原因2、本地的hexo主题的 `_config.yml` 文件配置有问题\n检查 `deploy` 字段有没有 问题\n## 2、`_config.yml` 文件配置  `deploy` 说明\n\n  字段 `type` 提交工具 一般为 `git`\n  字段 `repo` 静态文件仓库地址 `git@github.com:仓库名/博客名字.github.io.git`\n  字段 `branch` 注意该字段 **该字段是指执行 `hexo d` 命令后文件最后推送到远程库的分支**\n\n  完整例子（`youranme` 为要替换自己的数据）：\n  ```\n  deploy:\n    type: git\n    repo: git@github.com:youranme/youranme.github.io.git\n    branch: master\n  ```\n\n\n## 3、如何解决在多台电脑上提交博客\n**解决办法：利用 `github` 的分支**\ngithub 新建分支 `newBranch` 并设置为默认分支\n  (设置默认分支 当前代码库 -> setting -> Branchs -> Default branch 选择分支 -> 点击 Update)\n####  1）、首先将本地远程库克隆到本地 (此时的本地仓库默认指向的是 `newBranch`)\n```git\n  git clone 仓库地址\n```\n\n####  2）、然后此时仓库有两个分支 `newBranch` 和 `master` ;\n在当前克隆下来的文件夹里面执行 (需要安装 `hexo`)\n```hexo\n  hexo init\n```\n####  3）、在新电脑上 生成 `ssh` ;\n```git\n    ssh-keygen -t rsa -C 'github账号'\n```\n`ssh` 值在 `/用户/当前账户名/.ssh/id_rsa.pub` 的文件内\n\n####  4）、将值新建到 `guhub` 的 `ssh keys`:\ngithub账户 -> setting -> SSH and GPG keys -> SSH keys -> New SSH key、\n\n####  5）、设置本地账户信息\n```git\n    $ git config --global user.name \"yourname\"\n    $ git config --global user.email youeremail@example.com\n```\n\n## 6、将 hexo 当前目录下的文件 全部提交到远程库 `newBranch`\n\n#### 1）、本地预览\n新建博文\n```git\n  hexo new 'newBlogTitle'\n```\n\n生成静态文件\n```git\n    hexo g  // 生成文件\n```\n预览静态文件\n```git\n    hexo s  // 预览静态文件 访问localhost:4000\n```\n\n#### 2）、将修改的文件提交的远程仓库\n```git\n  git add .\n  git commit -m '提交备注'\n  git push\n```\n#### 3）、发布到远程仓库\n执行以下\n```git\n   hexo clean && hexo g && hexo d\n```\n此时会将博客的静态文件推送到 `master` 分支，\n同时访问 https://mogugit.github.io/ 也就能看到更新的内容\n\n## 7、更换电脑之后，只需要将远程仓库的分支克隆下来 在 `github` 中添加 `ssh` 就可以了\n每次更新文件只需要执行 步骤 8,9 就好了\n\n如果代码提交错误 那就回滚代码；\n首先通过 `git log` 获取相应的版本号\n```\n  git log\n```\n回滚\n```\n  git reset --hard 版本号\n```\n从新推送到远程仓库\n```\n   git push -f -u origin 分支名称\n```\n重新更新 代码\n```\n  git pull\n```\n## 8、[博客使用的图片可以使用免费的图床](https://zhuanlan.zhihu.com/p/35270383)\n\n**[路过图床](https://imgchr.com/)**\n\n  简介：支持免注册上传图片，永久存储，支持HTTPS加密访问和调用图片，提供多种图片链接格式，成立于2011年\n\n  限制：最大10M\n**[七牛云](https://portal.qiniu.com)**\n\n简介：注册认证后有10G永久免费空间，每月10G国内和10G国外流量，速度相当快，七牛云是国内专业CDN服务商，插件支持比较多，有免费ssl证书，但https流量收费\n**注意：七牛云30天后会回收测试域名，因此你`必须要绑定自己的已备案的域名`**\n\n图片上传限制：无\n\n**[公益图床](http://sbimg.cn)**\n\n长期保存需要注册使用，这个图床服务器在国内应该还用了cdn，总之速度非常快\n\n\n其他的可以[参考这里](https://zhuanlan.zhihu.com/p/35270383)\n","tags":["probelm","blog"],"categories":["skill"]},{"title":"工作git commit提交规范","url":"/2022/09/02/工作git-commit提交规范/","content":"#### git 提交规范\n**规范的优势**\n 1. 版本回退可以快速定位到指定版本\n 2. 清晰明了知道每次提交的内容\n 3. 统一规范\n \n**commit 提交格式**\n  commit 提交包括三个部分 `Header`, `Body`和 `Footer`;\n  其中 `Header` 是必须的, `Body`和`Footer`是可忽略。 \n范例如下：\n\n<!-- more -->\n```ts\n    <type>（scope）: <subject>\n    // 空行必须\n    <body>\n    // 空行必须\n    <footer> \n```\n**Header**\nHeader部分只有一行，包括`type`（必需）,`scope`(可忽略)和 `subject`(必需)；\n `type` 包括一下9个类型\n```text\n    feat: 新功能（feature）；\n    fix: 修补BUG；\n    docs: 文档（documentation）；\n    style: 样式修改（不影响代码运行的样式修改）；\n    refactor: 已有功能重构（既不是新增，也不是修改BUG）；\n    chore: 构建过程，辅助工具变更；\n    revert: 撤销，版本回退；\n    perf: 性能优化；\n    test: 测试相关；\n    improvement: 改进；\n    build: 打包相关，比如buil工具变更；\n    cli: 持续集成；\n```\n`scope` 影响范围，比如：数据层，控制层，试视图层：\n```text\n    all: 表示影响面大，比如修改了网络请求框架，会影响整个程序；\n    module: 表示影响某个模块，跟某些模块相关，比如登录，用户管理等；\n    location: 表示影响较小，只有某个小功能影响；\n```\n`subject` 简述本次提交的改动。\n\n**Body**\n`Body`是对本次提交的详细描述，可以分为很多行。例如：\n```text\n    xx/xxx.xx 修改内容\n    xx/xxx.xx 修改内容\n```\n\n**Footer**\nFooter 适用于 不兼容变更，关闭需求和Bug；\n- 关闭需求\n    ```text\n        close bugID, 需求ID,...\n    ```\n- 不兼容变动 如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。\n    ```text\n        BREAKING CHANGE: 项目webpack升级到4.0版本\n        xx插件替换成xx插件  \n    ```\n\n使用范例：\n```text\n    revert: feat(xx模块): 回退当前版本667ec到 sssee2\n\n    因为某次提交失误，造成xxx问题\n    xxx.vue\n    xxx.js\n\n    closes xxx\n```\n范例2:\n```text\n    chore(项目组件, 项目构建): 增加公用组件库xxx和xxx公用一套组件\n\n    为了解决xx问题， 引入公用组件库，使用方式见xx.md文档\n```","tags":["git commit","提交规范"]},{"title":"使用＜details＞标签在网页里面添加脚注","url":"/2020/12/25/使用＜details＞标签在网页里面添加脚注/","content":"\n使用 `details` 标签可以为文章添加相应注解\n代码：\n<!-- more -->\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n  <style>\n    details, summary {\n      display: inline;\n      vertical-align: super;\n      font-size: 0.75em;\n    }\n    summary {\n      cursor: pointer;\n    }\n    details[open] {\n      display: contents;\n    }\n    details[open]::before {\n      content: \" [\";\n    }\n    details[open]::after {\n      content: \"]\";\n    }\n  </style>\n</head>\n<body>\n  The most cited work in history, for example, is a 1951 paper\n   <details>\n      <summary>1</summary>\n      Lowry, O. H., Rosebrough, N. J., Farr, A. L. & Randall, R. J. J. Biol. Chem. 193, 265–275 (1951).\n   </details>\ndescribing an assay to determine the amount of protein in a solution.\n</body>\n</html>\n```\n效果如下：\n[![rRBzkt.gif](https://s3.ax1x.com/2020/12/25/rRBzkt.gif)](https://imgchr.com/i/rRBzkt)\n","tags":["html","网页注脚"]},{"title":"实现深度克隆/拷贝,解决循环引用","url":"/2020/10/29/实现深度克隆-拷贝-解决循环引用/","content":"**基础版(不能解决循环引用)**\n基础版\n```js\n\tfunction deepClone(obj){\n\t  // 如果参数为空则直接返回,如果为日期/正则 则也直接返回；\n\t  if( obj == null ) return obj;\n\t  if( obj instanceof Date ) return new Date(obj);\n\t  if( obj instanceof RegExp ) return new RegExp(obj);\n\t  if(typeof obj !== 'object') return obj;\n\t  let cloneObj = new obj.constructor; // 此时是为了获取 obj 的类型, 并且可以根据类型来新建相应的拷贝对象;\n\t  // 根据上文的对象类型,来进行填充;\n\t  for(let key in obj){\n\t    if(obj.hasOwnProperty(key)){ // 过滤掉对象元属性上面的属性;\n\t      cloneObj[key] = deepClone(obj[key])\n\t    }\n\t  }\n\t  return cloneObj;\n\t}\n\n```\n<!-- more -->\n执行结果\n```js\n\tlet od = {\n\t\t\tname: '张三',\n\t\t\tage: 18,\n\t\t\taddress: {\n\t\t\t\tprovince: '上海市',\n\t\t\t\tdistrict: '浦东新区'\n\t\t \t},\n\t\t \tdateVal: dateVal: new Date('2020-02-14').toLocaleString(),\n\t\t \tre:new RegExp()\n\t\t}\n\tvar cloneData = deepClone(od);\n\tconsole.log(cloneData);\n\t// cloneData 输出如下 {address:{province:\"上海市\",district:\"浦东新区\"},age:18,dateVal:\"2020/2/14 上午8:00:00\",name:\"张三\",re:/(?:)/,}\n```\n如果循环引用到导致爆栈\n```js\n\t// 如果循环引用 会直接导致爆栈;\n\tlet od = {\n\t\t\tname: '张三',\n\t\t\tage: 18,\n\t\t\taddress: {\n\t\t\t\tprovince: '上海市',\n\t\t\t\tdistrict: '浦东新区'\n\t\t \t},\n\t\t \tdateVal: dateVal: new Date('2020-02-14').toLocaleString(),\n\t\t \tre:new RegExp()\n\t\t}\n\tod.cloneSelf = cloneData\n\tvar cloneData = deepClone(od);\n\t// VM6546:5 Uncaught RangeError: Maximum call stack size exceeded\n```\n![内存栈溢出](https://img-blog.csdnimg.cn/20201028113031666.png#pic_center)\n**增强版(兼容循环引用)**\n```js\n\t// 该函数的关键点为 WeakMap, 主要是为了解决循环引用问题；\n\tfunction deepClone(obj,hash = new WeakMap()){\n\t  // 如果参数为空则直接返回,如果为日期/正则 则也直接返回；\n\t  if( obj == null ) return obj;\n\t  if( obj instanceof Date ) return new Date(obj);\n\t  if( obj instanceof RegExp ) return new RegExp(obj);\n\t  if(typeof obj !== 'object') return obj;\n\t  if(hash.has(obj)) return hash.get(obj); // 如果weakmap 中存在则直接返回; 解决 参数本身引用本身造成爆栈；\n\t  let cloneObj = new obj.constructor; // 此时是为了获取 obj 的类型, 并且可以根据类型来新建相应的拷贝对象;\n\n\t  hash.set(obj, cloneObj); // 将 obj 设置为对象则将对象放入 WeakMap 中, 拷贝的时候如果没有该值则直接从weakMap 中取就好了;\n\n\t  // 根据上文的对象类型,来进行填充;\n\t  for(let key in obj){\n\t    if(obj.hasOwnProperty(key)){ // 过滤掉对象元属性上面的属相\n\t      cloneObj[key] = deepClone(obj[key], hash)\n\t    }\n\t  }\n\t  return cloneObj;\n\t}\n```\n此时循环引用则正常输出\n```js\n\t// 如果循环引用 会直接导致爆栈;\n\tlet od = {\n\t\t\tname: '张三',\n\t\t\tage: 18,\n\t\t\taddress: {\n\t\t\t\tprovince: '上海市',\n\t\t\t\tdistrict: '浦东新区'\n\t\t \t},\n\t\t \tdateVal: dateVal: new Date('2020-02-14').toLocaleString(),\n\t\t \tre:new RegExp()\n\t\t}\n\tod.cloneSelf = cloneData\n\tvar cloneData = deepClone(od);\n\t// 输出如下\n\t// { address:{province:\"上海市\",district:\"浦东新区\"},age:18,dateVal:\"2020/2/14 上午8:00:00\",name:\"张三\",re:/(?:)/, cloneSelf : [Circular] }\n```\n`cloneSelf ` 属性为一个循环嵌套属性；\n![循环嵌套](https://img-blog.csdnimg.cn/20201028115005889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseV93dWd1aQ==,size_16,color_FFFFFF,t_70#pic_center)\n","tags":["js应用技巧","js 对象深度克隆/拷贝","深度克隆拷贝解决循环引用"]},{"title":"JS 设计模式-发布订阅与观察者模式","url":"/2020/10/15/JS-设计模式-发布订阅与观察者模式/","content":"JS 设计模式之发布订阅模式\n<!-- more -->\n```js\n\t// 发布/订阅模式\n\tfunction EventEmit(){\n\t  this._arr = [];\n\t}\n\t// 订阅\n\tEventEmit.prototype.on = function(callBack){\n\t  this._arr.push(callBack)\n\t}\n\t// 取消订阅\n\tEventEmit.prototype.unon = function(callBack){\n\t  this._arr.filter(fn=>{\n\t    if(fn !== callBack){\n\t      return fn;\n\t    }\n\t  })\n\t}\n\t// 发布\n\tEventEmit.prototype.emit = function(){\n\t  this._arr.forEach(fn=>fn.apply(this, arguments))\n\t}\n\n\tlet fn = new EventEmit();\n\tlet obj = {};\n\n\tfn.on(function(data,key){\n\t  obj[key] = data;\n\t  if(Object.keys(obj).length==2){\n\t    console.log(obj)\n\t  }\n\t})\n\n\tfn.emit('张三', 'name' )\n\tfn.emit(18,'age')\n```\n\nJS 设计模式之观察者模式\n\n```js\n\t// 被观察者/服务\n\tclass Serve {\n\t  constructor(){\n\t    this._arr = []\n\t  }\n\t  attch(callBack){\n\t    this._arr.push(callBack)\n\t  }\n\t  setState(val){\n\t    this._arr.forEach(fn=>{\n\t      fn.update(val)\n\t    })\n\t  }\n\t}\n\n\t// 观察者\n\tclass Observe {\n\t  constructor(props){\n\t    this.state = props;\n\t  }\n\t  update(val){\n\t    console.log('name-',this.state, 'datra-',val)\n\t  }\n\t}\n\n\t// 新建观察者\n\tlet o1 = new Observe('name1')\n\tlet o2 = new Observe('name2')\n\n\t// 新建服务\n\tlet server = new Serve();\n\n\t// 为服务添加观察者；\n\tserver.attch(o1) // name- name1 datra- asdfasd\n\tserver.attch(o2) // name- name2 datra- asdfasd\n\n\t// 服务运行观察者记录到\n\tserver.setState('asdfasd')\n```\n发布/订阅模式和观察者模式的区别在于：\n\n**发布订阅模式是发布和订阅相互独立的，耦合度较松；\n观察者模式是将观察者耦合到服务内部，消息触发之后会通知/执行观察者的操作；**\n","tags":["设计模式","发布订阅","js应用技巧"]},{"title":"js - 回调函数的应用技巧之函数预处理","url":"/2020/10/15/js-回调函数的应用技巧之函数预处理/","content":"\n#### 回调函数的应用技巧之函数预处理\n函数前置\n<!-- more -->\n```js\n\t// 前置函数 在当前函数执行前面增加一个函数实现再不更改原函数的情况下 对目标进行预处理;\n\tFunction.prototype.before = function(callBack){\n\t  let that = this; // 将 this 指向原函数；\n\t  return function(){\n\t    callBack() // 执行 前置函数\n\t    that.apply(that, arguments) // 执行原函数\n\t  }\n\t}\n\n\t// 原函数\n\tfunction fn(data){\n\t  console.log('原函数', data)\n\t}\n\n\t// 回调操作\n\tfunction cb(){\n\t  console.log('callBack')\n\t}\n\n\t// 为原函数增加前置函数 before\n\tlet newFn = fn.before(cb)\n\n\t// 执行函数\n\tnewFn(123) // '原函数 123'\n\n```\n**应用场景：在不更改原函数的情况下对目标进行预处理**\n","tags":["js应用技巧","函数回调应用","前置函数","函数预执行"]},{"title":"js - 回调函数的应用技巧之计数执行","url":"/2020/10/15/js-回调函数的应用技巧之计数执行/","content":"在一些业务场景会有两个独立函数共同修改一个对象，而我们又不知道对象什么何时完成的时候，就要用回调函数来进行解决。\n\n如：有两个单独文本文件，我们需要获取里面的内容来填充一个对象，我们在填充完成之后来获取对象。\n\n获取文本文件并填充\n<!-- more -->\n```js\n\tlet fs = require('fs');\n\n\tfunction fn(acount, callBack){\n\t  let obj = {};\n\t  return function(key, data){\n\t    obj[key] = data;\n\n\t    // 计数自减\n\t    if(--acount == 0){\n\t      callBack(obj);\n\t    } else {\n\t      console.log('未执行完毕');\n\t    }\n\t  }\n\t}\n\n\tfunction getData(data){\n\t  console.log('获取完毕', data);\n\t}\n\n\t// 设置目标次数以及回调函数；\n\tlet newFn = new fn(2, getData);\n\n\t// 获取数据1: 张三\n\tfs.readFile('./1.text', 'utf8', function(err, data){\n\t  if(err){\n\t    console.log(err);\n\t    return;\n\t  }\n\t  newFn('name', data);\n\t});\n\n\t// 获取数据2: 18\n\tfs.readFile('./2.text', 'utf8', function(err, data){\n\t  if(err){\n\t    console.log(err);\n\t    return;\n\t  }\n\t  newFn('age', data);\n\t})\n\n```\n应用场景为 需要多次调用、异步执行，但是不知道结果是否符合的情况下，可以指定次数来解决问题；\n","tags":["js应用技巧","函数回调应用"]},{"title":"函数防抖与节流","url":"/2020/10/14/函数防抖与节流/","content":"在前端开发的过程中，经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。所以诞生了 **防抖与节流函数**\n\n**防抖（debounce）**\n\n**所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。**\n<!-- more -->\n页面部分\n```js\n<div id=\"box\" style=\"height:150px;line-height:150px;text-align:center; color: #fff;background-color:#ddd;font-size:80px;\"></div>\n<script>\n    let num = 1;\n    let content = document.getElementById('box');\n\n    function count() {\n        content.innerHTML = num++;\n    };\n    content.onmousemove = count;\n</script>\n```\n\n在上述代码中，div 元素绑定了 mousemove 事件，当鼠标在 div（灰色）区域中移动的时候会持续地去触发该事件导致频繁执行函数。效果如下\n![连续变化](https://img-blog.csdnimg.cn/20201014111840294.png#pic_center)\n可以看到，在没有通过其它操作的情况下，函数被频繁地执行导致页面上数据变化特别快。所以，接下来让我们来看看防抖和节流是如何去解决这个问题的。\n\n防抖函数分为非立即执行版和立即执行版。\n\n非立即执行版：\n```js\n  // 非立即执行\n  function debounce(func, wait){\n    let timeout;\n    return function(){ // 返回函数的 this 指向为当前的操作对象;\n      let that = this;\n      timeout && clearInterval(timeout);\n      timeout = setTimeout(function(){\n        func.apply(that, arguments);\n      }, wait)\n    }\n  }\n```\n非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。\n\n使用上述绑定 mousemove 事件的例子，通过上面的防抖函数\n```js\n\tcontent.onmousemove = debounce(count,1000);\n```\n![防抖操作](https://img-blog.csdnimg.cn/20201014112052419.png#pic_center)\n可以看到，在触发事件后函数 1 秒后才执行，而如果我在触发事件后的 1 秒内又触发了事件，则会重新计算函数执行时间。\n\n上述防抖函数的代码还需要注意的是 this 和 参数的传递\n```js\n\tlet context = this;\n\tlet args = arguments;\n```\n防抖函数的代码使用这两行代码来获取 this 和 参数，是为了让 debounce 函数最终返回的函数 this 指向不变以及依旧能接受到 e 参数。\n\n立即执行版：\n```js\n  // 带有首次执行 immediate\n  function debounce(func, wait){\n      let timeout;\n      return function(){\n        let that = this;\n        let arg = arguments;\n\n        timeout && clearTimeout(timeout);\n\n        let nowRun = !timeout;\n\n        timeout = setTimeout(()=> timeout = null, wait)\n        nowRun && func.apply(that, arg)\n      }\n  }\n\n```\n立即执行版的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。\n\n![立即执行](https://img-blog.csdnimg.cn/20201014114444349.png#pic_center)\n我们需要根据不同的场景来决定我们需要使用哪一个版本的防抖函数，一般来讲上述的防抖函数都能满足大部分的场景需求。但我们也可以将非立即执行版和立即执行版的防抖函数结合起来，最终实现防抖：\n\n最终版：\n```js\n/**\n * @desc 函数防抖\n * @param func 函数\n * @param wait 延迟执行毫秒数\n * @param immediate true 表立即执行，false 表非立即执行\n */\n  function debounce(func, wait, immediate){\n      let timeout;\n      return function(){\n        let that = this;\n        let arg = arguments;\n        timeout && clearTimeout(timeout);\n        if(immediate){\n          let nowRun = !timeout;\n          timeout = setTimeout(()=> timeout = null, wait)\n          nowRun && func.apply(that, arg)\n        } else {\n          timeout = setTimeout(()=> func.apply(that, arg) , wait)\n        }\n      }\n  }\n```\n\n**节流（throttle）**\n\n**所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。**节流会稀释函数的执行频率。\n\n对于节流，一般有两种方式可以实现，分别是时间戳版和定时器版。\n\n时间戳版：\n```js\n\tfunction throttle(func, wait) {\n\t    let previous = 0;\n\t    return function() {\n\t        let now = Date.now();\n\t        let context = this;\n\t        let args = arguments;\n\t        if (now - previous > wait) {\n\t            func.apply(context, args);\n\t            previous = now;\n\t        }\n\t    }\n\t}\n```\n使用方式如下:\n```js\n\tcontent.onmousemove = throttle(count,1000);\n```\n效果如下：\n![时间戳](https://img-blog.csdnimg.cn/20201014114906732.png#pic_center)\n可以看到，在持续触发事件的过程中，函数会立即执行，并且每 1s 执行一次。\n\n定时器版:\n```js\n\tfunction throttle(func, wait) {\n\t    let timeout;\n\t    return function() {\n\t        let context = this;\n\t        let args = arguments;\n\t        if (!timeout) {\n\t            timeout = setTimeout(() => {\n\t                timeout = null;\n\t                func.apply(context, args)\n\t            }, wait)\n\t        }\n\n\t    }\n\t}\n```\n使用方式同上\n![定时器版](https://img-blog.csdnimg.cn/20201014115047206.png#pic_center)\n可以看到，在持续触发事件的过程中，函数不会立即执行，并且每 1s 执行一次，在停止触发事件后，函数还会再执行一次。\n\n我们应该可以很容易的发现，其实时间戳版和定时器版的节流函数的区别就是，**时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候**。\n\n最终版：\n```js\n\t/**\n\t * @desc 函数节流\n\t * @param func 函数\n\t * @param wait 延迟执行毫秒数\n\t * @param type 1 表时间戳版，2 表定时器版\n\t */\n\tfunction throttle(func, wait ,type) {\n\t    if(type===1){\n\t        let previous = 0;\n\t    }else if(type===2){\n\t        let timeout;\n\t    }\n\t    return function() {\n\t        let context = this;\n\t        let args = arguments;\n\t        if(type===1){\n\t            let now = Date.now();\n\n\t            if (now - previous > wait) {\n\t                func.apply(context, args);\n\t                previous = now;\n\t            }\n\t        }else if(type===2){\n\t            if (!timeout) {\n\t                timeout = setTimeout(() => {\n\t                    timeout = null;\n\t                    func.apply(context, args)\n\t                }, wait)\n\t            }\n\t        }\n\t    }\n\t}\n```\n参考文章：\n[https://github.com/mqyqingfeng/Blog/issues/22](https://github.com/mqyqingfeng/Blog/issues/22)\n\n[https://github.com/mqyqingfeng/Blog/issues/26](https://github.com/mqyqingfeng/Blog/issues/26)\n\n[函数防抖与节流](https://www.jianshu.com/p/c8b86b09daf0)\n\n[underscore 源码](https://underscorejs.net/docs/underscore.html)\n","tags":["js应用技巧","防抖与节流"]},{"title":"hexo+next 增加搜索功能","url":"/2020/09/17/hexo-next-增加搜索功能/","content":"#### 1、安装本地搜索插件 hexo-generator-search\n在博客根目录安装搜索插件\n```git\n  # 安装插件，用于生成博客索引数据（在博客根目录下执行下列命令）：\n  npm install hexo-generator-search --save\n```\n<!-- more -->\n安装之后，会在站点目录的 `public` 文件夹下创建一个 `search.xml` 文件。（如果没有 `search.xml` 文件，请继续往下看）\n\n#### 2、修改站点配置文件(如果上一步没有找到 `search.xml`文件 则可以跳过 )\n在主题配置文件中的 `_config.yml` 中添加如下内容：\n```git\n  # Search\n  search:\n    path: ./public/search.xml\n    field: post\n    format: html\n    limit: 10000\n```\n- path：索引文件的路径，相对于站点根目录\n- field：搜索范围，默认是 post，还可以选择 page、all，设置成 all 表示搜索所有页面\n- limit：限制搜索的条目数\n\n#### 3、主题配置文件\n\n在主题配置文件 `_config.yml` 中找到如下内容：\n```git\n  local_search:\n    enable: true\n    trigger: auto\n    top_n_per_article: 1\n```\n\n确保 `enable` 设成 `true`。\n\n`top_n_per_article` 字段表示在每篇文章中显示的搜索结果数量，设成 `-1` 会显示每篇文章的所有搜索结果数量。\n\n然后，重新部署网站即可愉快的使用本地搜索功能了。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200917110556774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseV93dWd1aQ==,size_16,color_FFFFFF,t_70#pic_center)\n以上就是在博客添加本地搜索~\n","tags":["blog 增加搜索功能","hexo搜索"]},{"title":"Python出现Could not find a version that satisfies the requirement openpyxl (from versions: )","url":"/2020/09/14/Python出现Could-not-find-a-version-that-satisfies-the-requirement-openpyxl-from-versions/","content":"##### 一.环境\n使用python3.7时，用pip安装openpyxl出现如下错误：\n<!-- more -->\n[![wD5qh9.png](https://s1.ax1x.com/2020/09/14/wD5qh9.png)](https://imgchr.com/i/wD5qh9)\n#### 二. 解决方案\n可能是python国内网络的问题，这时我们用国内的镜像源来加速。\n```python\npip install 包名 -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com\n# 这个是豆瓣源\n# --trusted-host pypi.douban.com 这是为了获得ssl证书的认证，要不然会报错\n```\n[![wD5OpR.png](https://s1.ax1x.com/2020/09/14/wD5OpR.png)](https://imgchr.com/i/wD5OpR)\n#### 三. pip和pip3的区别\n其实这两个命令效果是一样的，没有区别：\n\n比如安装库openpyxl，pip3 install openpyxl或者pip install openpyxl：只是当一台电脑同时有多个版本的Python的时候，用pip3就可以自动区分用Python3来安装库。是为了避免和Python2发生冲突的。\n（2）如果你的电脑只安装了Python3，那么不管用pip还是pip3都一样的。\n安装了python3之后，会有pip3\n（1）使用pip install XXX ：\n新安装的库会放在这个目录下面：python2.7/site-packages\n（2）使用pip3 install XXX ：\n新安装的库会放在这个目录下面：python3.7/site-packages\n（3）如果使用python3执行程序，那么就不能importpython2.7/site-packages中的库。\n","tags":["python","python包安装源"]},{"title":"你不知道的快速复制数组小秘密","url":"/2020/09/11/你不知道的快速复制数组小秘密/","content":"\n**方法1、arrayObject.slice(start,end) 快速深度复制一个多维数组**\n关于 [`slice(start,end)`方法说明](https://www.w3school.com.cn/js/jsref_slice_array.asp)\n\n| 参数 | 描述 |\n|:--------:|:------------|\n| start | 必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。 |\n| end | 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 |\n\n<!-- more -->\n###### 返回值\n返回一个新的数组，包含从 `start` 到 `end` （不包括该元素）的 `arrayObject` 中的元素。\n如果想删除数组中的一段元素，应该使用方法 `Array.splice()`。\n**`splice()  方法会直接对数组进行修改`**。\n\n例：\n```javascript\n\tvar classArr= [\n\t\t[\n\t\t\t{\n\t\t\t\tname: 'stundentA',\n\t\t\t\tage: 18,\n\t\t\t\tsubject:['科目一','科目二','科目三']\n\t\t\t}\n\t\t],\n\t\t[\n\t\t\t{\n\t\t\t\tname: 'stundentB',\n\t\t\t\tage: 22,\n\t\t\t\tsubject:['科目1','科目2','科目3']\n\t\t\t}\n\t\t],\n\t\t[\n\t\t\t{\n\t\t\t\tname: 'stundentC',\n\t\t\t\tage: 21,\n\t\t\t\tsubject:['科目A','科目B','科目C']\n\t\t\t}\n\t\t]\n\t];\n  var copyArr = classArr.slice();\n\n\tclassArr.splice(2,1); // [{name: 'stundentC',age: 21,subject:['科目A','科目B','科目C']}]\n\tconsole.log(classArr) // [[{name: 'stundentA',age: 18,subject:['科目一','科目二','科目三']}],[{name: 'stundentB',age: 22,subject:['科目1','科目2','科目3']}]]\n\tconsole.log(copyArr) // [[{name: 'stundentA',age: 18,subject:['科目一','科目二','科目三']}],[{name: 'stundentB',age: 22,subject:['科目1','科目2','科目3']}],[{name: 'stundentC',age: 21,subject:['科目A','科目B','科目C']}]]\n\n```\n**方法2、使用es6的解构**\n```javascript\n\tvar classArr= [\n\t\t[\n\t\t\t{\n\t\t\t\tname: 'stundentA',\n\t\t\t\tage: 18,\n\t\t\t\tsubject:['科目一','科目二','科目三']\n\t\t\t}\n\t\t],\n\t\t[\n\t\t\t{\n\t\t\t\tname: 'stundentB',\n\t\t\t\tage: 22,\n\t\t\t\tsubject:['科目1','科目2','科目3']\n\t\t\t}\n\t\t],\n\t\t[\n\t\t\t{\n\t\t\t\tname: 'stundentC',\n\t\t\t\tage: 21,\n\t\t\t\tsubject:['科目A','科目B','科目C']\n\t\t\t}\n\t\t]\n\t];\n\tvar copyArr = [...classArr];\n  classArr.splice(2,1); // [{name: 'stundentC',age: 21,subject:['科目A','科目B','科目C']}]\n\n\tconsole.log(classArr) // [[{name: 'stundentA',age: 18,subject:['科目一','科目二','科目三']}],[{name: 'stundentB',age: 22,subject:['科目1','科目2','科目3']}]]\n  console.log(copyArr) // [[{name: 'stundentA',age: 18,subject:['科目一','科目二','科目三']}],[{name: 'stundentB',age: 22,subject:['科目1','科目2','科目3']}],[{name: 'stundentC',age: 21,subject:['科目A','科目B','科目C']}]]\n\n```\n","tags":["javascript","copy Array"]},{"title":"axios 个人配置拦截器","url":"/2020/08/06/axios-个人配置拦截器/","content":"\n个人配置 axios 拦截器\n<!-- more -->\n```js\nimport Vue from 'vue';\nimport axios from 'axios';\nimport { Message } from 'element-ui';\nVue.component(Message.name, Message);\nlet sessionLoginId = sessionStorage.getItem('LoginId') || '';\naxios.interceptors.request.use((res) => {\n  res.headers['TIME_TOKEN'] = new Date().getTime();\n  res.headers['Cache-Control'] = 'no-cache'; // 以秒为单位 no-cache\n  res.headers['Token'] = sessionLoginId;\n  try {\n    if (!res) return;\n    res.headers['content-type'] = 'application/json; charset=UTF-8';\n    if (res.method === 'get') {\n      res.data = {unused: 0};\n    }\n  } catch (e) {\n    console.error(e);\n  }\n  return res;\n}, (err) => {\n  return Promise.reject(err);\n});\n// 添加响应拦截器-错误处理\naxios.interceptors.response.use(res => {\n    return res;\n  },\n  err => {\n    // 无权限-40013  sessionId过期-40005 均跳转到登录\n    if (err && err.response && err.response.data.code === 40005) {\n      location.href = err.response.data.extraInfo;\n    } else if (err && err.response && err.response.data.code === 40013) {\n      Vue.prototype.$message({\n        message: err.response.data.msg || '系统异常，请联系管理员！',\n        type: 'error'\n      });\n      setTimeout(function() {\n        axios.get('/admin/logout');\n        sessionStorage.clear();\n      }, 3000);\n    } else {\n      let errRes = err.response.data.extraInfo || err.response.data.msg || '系统异常，请联系管理员！';\n      if (errRes.length >= 40) errRes = errRes.slice(0, 40) + '...';\n\n      Vue.prototype.$message({\n        message: errRes,\n        type: 'error'\n      });\n    }\n    return Promise.reject(err);\n  }\n);\n\nexport default class BaseApi {\n  constructor() {\n    this.axios = axios;\n  }\n}\n\n```\n记录配置拦截器;\n","tags":["axios","axios 拦截器"]},{"title":"startsWith() 使用","url":"/2020/07/20/startsWith-使用/","content":"\n`startsWith()` 方法用于检测字符串是否以指定的子字符串开始。\n\n如果是以指定的子字符串开头返回 `true`，否则 `false`。\n\n`startsWith()` 方法对大小写敏感。\n```js\n\tvar str = \"Hello world\";\n\tvar n = str.startsWith(\"Hello\");\n\tconsole.log(n) // true\n```\n<!-- more -->\n##### 语法\n```js\n\tstring.startsWith(searchvalue, start)\n```\n##### 参数值\n| 参数 | 描述 |\n|:---- |:-----|\n|  searchvalue  |  必需，要查找的字符串。|\n|  start  |  可选，查找的开始位置，默认为 0。|\n\n##### 返回值\n|返回值|\n|:--|\n| 如果字符串是以指定的子字符串开头返回 true，否则 false。 |\n\n```js\n\tvar str = \"Hello world\";\n\tvar n = str.startsWith(\"o\", 4);\n\tconsole.log(n) // true\n```\n\n\n","tags":["startsWith()","js 实用方法"]},{"title":"转：http状态码诠释","url":"/2020/06/22/转：http状态码诠释/","content":"#### 一、http 状态码诠释\n[转自：HTTP协议状态码详解（HTTP Status Code）](https://www.cnblogs.com/shanyou/archive/2012/05/06/2486134.html)\n\n使用ASP.NET/PHP/JSP或者javascript都会用到http的不同状态，一些常见的状态码为：\n200 – 服务器成功返回网页 404 – 请求的网页不存在 503 – 服务不可用\n**1、1xx（临时响应）**\n表示临时响应并需要请求者继续执行操作的状态代码。\n\n代码   说明\n- 100   （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。\n- 101   （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。\n<!-- more -->\n**2、2xx （成功）**\n表示成功处理了请求的状态代码。\n\n代码   说明\n- 200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。\n- 201   （已创建）  请求成功并且服务器创建了新的资源。\n- 202   （已接受）  服务器已接受请求，但尚未处理。\n- 203   （非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。\n- 204   （无内容）  服务器成功处理了请求，但没有返回任何内容。\n- 205   （重置内容） 服务器成功处理了请求，但没有返回任何内容。\n- 206   （部分内容）  服务器成功处理了部分 GET 请求。\n\n**3、3xx （重定向）**\n表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。\n\n代码   说明\n- 300   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。\n- 301   （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。\n- 302   （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\n- 303   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。\n- 304   （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。\n- 305   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。\n- 307   （临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\n\n**4、4xx（请求错误）**\n这些状态代码表示请求可能出错，妨碍了服务器的处理。\n\n代码   说明\n- 400   （错误请求） 服务器不理解请求的语法。\n- 401   （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。\n- 403   （禁止） 服务器拒绝请求。\n- 404   （未找到） 服务器找不到请求的网页。\n- 405   （方法禁用） 禁用请求中指定的方法。\n- 406   （不接受） 无法使用请求的内容特性响应请求的网页。\n- 407   （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。\n- 408   （请求超时）  服务器等候请求时发生超时。\n- 409   （冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。\n- 410   （已删除）  如果请求的资源已永久删除，服务器就会返回此响应。\n- 411   （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。\n- 412   （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。\n- 413   （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。\n- 414   （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。\n- 415   （不支持的媒体类型） 请求的格式不受请求页面的支持。\n- 416   （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。\n- 417   （未满足期望值） 服务器未满足”期望”请求标头字段的要求。\n\n**5、5xx（服务器错误）**\n这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。\n\n代码   说明\n- 500   （服务器内部错误）  服务器遇到错误，无法完成请求。\n- 501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。\n- 502   （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。\n- 503   （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。\n- 504   （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。\n- 505   （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。\n\n\n[RFC 6585](https://tools.ietf.org/html/rfc6585) 最近刚刚发布，该文档描述了 4 个新的 HTTP 状态码。\n\nHTTP 协议还在变化？是的，HTTP 协议一直在演变，新的状态码对于开发 REST 服务或者说是基于 HTTP 的服务非常有用，下面我们为你详细介绍这四个新的状态码以及是否应该使用。\n\n#### 二、其他扩展\n\n**428 Precondition Required (要求先决条件)**\n先决条件是客户端发送 HTTP 请求时，如果想要请求能成功必须满足一些预设的条件。\n\n一个好的例子就是 If-None-Match 头，经常在 GET 请求中使用，如果指定了 If-None-Match ，那么客户端只在响应中的 ETag 改变后才会重新接收回应。\n\n先决条件的另外一个例子就是 If-Match 头，这个一般用在 PUT 请求上用于指示只更新没被改变的资源，这在多个客户端使用 HTTP 服务时用来防止彼此间不会覆盖相同内容。\n\n当服务器端使用 [428 Precondition Required](https://tools.ietf.org/html/rfc6585#section-3) 状态码时，表示客户端必须发送上述的请求头才能执行请求，这个方法为服务器提供一种有效的方法来阻止 'lost update' 问题。\n\n**429 Too Many Requests (太多请求)**\n当你需要限制客户端请求某个服务数量时，该状态码就很有用，也就是请求速度限制。\n\n在此之前，有一些类似的状态码，例如 '509 Bandwidth Limit Exceeded'. Twitter 使用 420 （这不是HTTP定义的状态码）\n\n如果你希望限制客户端对服务的请求数，可使用 [429 状态码](https://dev.twitter.com/docs/error-codes-responses)，同时包含一个 Retry-After 响应头用于告诉客户端多长时间后可以再次请求服务。\n\n**431 Request Header Fields Too Large (请求头字段太大)**\n某些情况下，客户端发送 HTTP 请求头会变得很大，那么服务器可发送 [431 Request Header Fields Too Large](https://tools.ietf.org/html/rfc6585#section-5) 来指明该问题。\n\n我不太清楚为什么没有 430 状态码，而是直接从 429 跳到 431，我尝试搜索但没有结果。唯一的猜测是 430 Forbidden 跟 403 Forbidden 太像了，为了避免混淆才这么做的，天知道！\n\n**511 Network Authentication Required (要求网络认证)**\n对我来说这个状态码很有趣，如果你在开发一个 HTTP 服务器，你不一定需要处理该状态码，但如果你在编写 HTTP 客户端，那这个状态码就非常重要。\n\n如果你频繁使用笔记本和智能手机，你可能会注意到大量的公用 WIFI 服务要求你必须接受一些协议或者必须登录后才能使用。\n\n这是通过拦截HTTP流量，当用户试图访问网络返回一个重定向和登录，这很讨厌，但是实际情况就是这样的。\n\n使用这些“拦截”客户端，会有一些讨厌的副作用。在 RFC 中有提到这两个的例子：\n\n- 如果你在登录WIFI前访问某个网站，网络设备将会拦截首个请求，这些设备往往也有自己的网站图标 ‘favicon.ico'。登录后您会发现，有一段时间内你访问的网站图标一直是WIFI登录网站的图标。\n- 如果客户端使用HTTP请求来查找文档（可能是JSON），网络将会响应一个登录页，这样你的客户端就会解析错误并导致客户端运行异常，在现实中这种问题非常常见。\n因此 511 状态码的提出就是为了解决这个问题。\n\n如果你正在编写 HTTP 的客户端，你最好还是检查 511 状态码以确认是否需要认证后才能访问。\n","tags":["http code"]},{"title":"利用 Qrcode 和 canvas 绘制带有 icon 的二维码","url":"/2020/06/17/利用-Qrcode-和-canvas-绘制带有-icon-的二维码/","content":"#### canvas生成二维码附带icon并实现下载\n参考地址 https://blog.csdn.net/chy555chy/article/details/85785819\n\n利用 [qrcode](https://github.com/soldair/node-qrcode) 生成二维码是不带 `icon` 的，去网上[查找解决方案](https://blog.csdn.net/chy555chy/article/details/85785819)需要修改源码。\n所以只好自己开搞了\n效果如下：\n![NEz2n0.png](https://s1.ax1x.com/2020/06/17/NEz2n0.png)\n代码如下\n<!-- more -->\n```js\n<template>\n  <div>\n    <!-- 二维码和icon -->\n    <img :src=\"rediusIconSrc\" alt=\"ICON\">\n    <img :src=\"qrCodeSrc\" alt=\"qrcode\">\n    <img :src=\"iconCodeSrc\" alt=\"IconAndQrcode\">\n    <button @click=\"getQrcode\">下载</button>\n  </div>\n</template>\n<script>\nimport QRCode from 'qrcode'; // 需安装 qrcode 插件;\nexport default {\n  data() {\n    return {\n      qrCodeSrc: '',\n      rediusIconSrc: '',\n      iconCodeSrc: '',\n      qrCodeW: '200',\n      qrCodeH: '200',\n      codeContext: 'text123',\n      iconScale: 0.2 // icon 占二维码的比例;\n    };\n  },\n  mounted() {\n    this.getCanvas(this.codeContext);\n  },\n  methods: {\n    getQrcode() {\n      let _a = document.createElement('a');\n      _a.href = this.iconCodeSrc;\n      _a.download = '带有 icon 的二维码';\n      _a.click();\n    },\n    getCanvas(codeContext, option = {errorCorrectionLevel: 'H', margin: 1}) {\n        // 配置参数 参考https://github.com/soldair/node-qrcode#options\n        // var opts = {\n        //   errorCorrectionLevel: 'H', // 容错级别 low, medium, quartile, high or L, M, Q, H.\n        //   type: 'image/jpeg', // 图片类型\n        //   quality: 0.9, // 透明度 貌似没啥效果\n        //   maskPattern: 1, // 遮罩图案\n        //   margin: 1, // 二维码距离边框的距离 单位为4px 默认值1个单位\n        //   color: { // 二维码 码块的颜色\n        //     dark: '#010599FF', // 默认值 #000000\n        //     light: '#FFBF60FF' // 默认值 #ffffff\n        //   }\n        // };\n\n        QRCode.toDataURL(codeContext, option, (err, url) => {\n          if (err) throw err;\n          // 生成二维码图片地址\n          this.qrCodeSrc = url;\n\n          // 二维码 转化为 canvas 并将 icon 画入到 canvas 中，然后导出;\n          this.addicon();\n        });\n    },\n    // 生成带边框及圆角的 icon 图片;\n    addicon(X = 0, Y = 0, W, H, radius = 5, birderW = 2, borderColor = '#fff', isbgColor = true, bgColor = 'rgba(255,255,255, 1)') {\n      let c = document.createElement('canvas');\n        c.width = this.qrCodeW * this.iconScale;\n        c.height = this.qrCodeH * this.iconScale;\n        let _w = W || c.width, _h = H || c.height;\n        let ctx = c.getContext('2d');\n\n        // 是否设置背景颜色\n        if (isbgColor) {\n          ctx.fillStyle = bgColor;\n          ctx.fillRect(0, 0, c.width, c.height);\n        }\n        this.drawRoundRect(ctx, X, Y, _w, _h, radius, birderW, borderColor);\n        let img = document.createElement('img');\n\n        // 网络图片直接给地址;\n        img.src = 'https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2069790559,642682254&fm=26&gp=0.jpg';\n\n        // 如果是本地图片请使用 require() 引入;\n        // img.src = require(src); // src 不能使变量 会查找不到;\n\n        // 解决 访问网络图片属于跨域操作 Failed to execute 'toDataURL' on 'HTMLCanvasElement': Tainted canvases may not be exported.\n        img.setAttribute('crossOrigin', 'Anonymous');\n        img.onload = () => {\n          ctx.clip();\n          ctx.drawImage(img, 0, 0, 40, 40);\n          ctx.restore();\n          this.rediusIconSrc = c.toDataURL();\n          this.mergeImg();\n        };\n    },\n    // 圆角 icon 和 二维码 合并到一起;\n    mergeImg() {\n      let c = document.createElement('canvas');\n        c.width = this.qrCodeW;\n        c.height = this.qrCodeH;\n        let ctx = c.getContext('2d');\n        let bg = document.createElement('img');\n        let icon = document.createElement('img');\n        bg.src = this.qrCodeSrc;\n        icon.src = this.rediusIconSrc;\n\n        let _bgLoad = new Promise((resolve, reject) => {\n          try {\n            bg.onload = () => resolve();\n          } catch (error) {\n            reject(error);\n          }\n        });\n        let _iconLoad = new Promise((resolve, reject) => {\n          try {\n            icon.onload = () => resolve();\n          } catch (error) {\n            reject(error);\n          }\n        });\n\n        Promise.all([_bgLoad, _iconLoad]).then(res => {\n          let w = this.qrCodeW;\n          let h = this.qrCodeH;\n          let iconW = w * this.iconScale;\n          let iconH = h * this.iconScale;\n          let iconX = (w - iconW) / 2;\n          let iconY = (h - iconH) / 2;\n          // 画二维码\n          ctx.drawImage(bg, 0, 0, w, h);\n          // 画icon\n          ctx.drawImage(icon, iconX, iconY, iconW, iconH);\n          // 转化为图片 src;\n          this.iconCodeSrc = c.toDataURL();\n        }).catch(e => {\n          console.log('error-', e);\n        });\n    },\n    // 画圆角 ctx 上下文 x,y 起始位置 width,height icon的宽高 radius 圆角的角度 lineWidth 边框的宽度 lineColor 边框的颜色\n    drawRoundRect(ctx, x, y, width, height, radius, lineWidth, lineColor) {\n      ctx.lineWidth = lineWidth;\n      ctx.strokeStyle = lineColor;\n      ctx.beginPath();\n      ctx.arc(x + radius, y + radius, radius, Math.PI, Math.PI * 3 / 2);\n      ctx.lineTo(width - radius + x, y);\n      ctx.arc(width - radius + x, radius + y, radius, Math.PI * 3 / 2, Math.PI * 2);\n      ctx.lineTo(width + x, height + y - radius);\n      ctx.arc(width - radius + x, height - radius + y, radius, 0, Math.PI * 1 / 2);\n      ctx.lineTo(radius + x, height + y);\n      ctx.arc(radius + x, height - radius + y, radius, Math.PI * 1 / 2, Math.PI);\n      ctx.closePath();\n      ctx.stroke();\n    }\n  }\n};\n</script>\n\n```\n\n","tags":["canvas","qrcode"]},{"title":"使用encodeURI和decodeURI转码和解码","url":"/2020/06/02/使用encodeURI和decodeURI转码和解码/","content":"**encodeURI() 函数可把字符串作为 URI 进行编码。**\n\n**语法:**\nencodeURI(URIstring)\n\n| 参数 | 描述 |\n| ------------- | ------------- |\n|URIstring |必需。一个字符串，含有 URI 或其他要编码的文本。|\n\n**返回：**\n`URIstring` 的副本，其中的某些字符将被十六进制的转义序列进行替换。\n\n**说明**\n该方法不会对 `ASCII` 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： `- _ . ! ~ * ' ( )` 。\n<!-- more -->\n该方法的目的是对 `URI` 进行完整的编码，因此对以下在 `URI` 中具有特殊含义的 `ASCII` 标点符号，`encodeURI()` 函数是不会进行转义的：`;/?:@&=+$,#`\n**可以[使用encodeURIComponent()和decodeURIComponent()](https://blog.csdn.net/qq_39712029/article/details/81003518)来进行转义**\n\n```\nvar a =\"张三\";\n\nencodeURI(a)// \"%E5%BC%A0%E4%B8%89\"\n```\n\n**decodeURI() 函数可对 encodeURI() 函数编码过的 URI 进行解码。**\n\n**语法**\ndecodeURI(URIstring)\n\n**描述**\n| 参数 | 描述 |\n| ------------- | ------------- |\n|URIstring |必需。一个字符串，含有 URI 或其他要解码的文本。|\n\n**返回值**\nURIstring 的副本，其中的十六进制转义序列将被它们表示的字符替换。\n\n```\nvar b = encodeURI(\"张三\")；//%E5%BC%A0%E4%B8%89\ndecodeURI(b) //张三\n```\n"},{"title":"commonjs使用 范例","url":"/2020/06/02/commonjs使用-范例/","content":"commonJS 规范  千言万语不如一行代码\n例\n<!-- more -->\n```\n//example.js\nvar n = 1;\nfunction sayHello( name ){\n\tvar name = name || \"Tom\";\n\treturn \"Hello~\"+name\n}\nfunction addFn(val){\n    var val = val.x+val.y;\n    return val\n}\nmodule.exports ={\n\tn:n,\n\tsayHello:sayHello,\n\taddFn:addFn\n}\n\n```\n使用requier()引入使用\n\n```\n//main.js\nvar example = require('./example.js');\nvar addNum = {\n\t\"x\":10,\n\t\"y\":5\n}\nconsole.log( example )//查看example输出的对外模块接口；\nconsole.log( example.n )//1;\nconsole.log( example.sayHello(\"Jack\") )// \"Hello~ Jack\";\nconsole.log( example.addFn(addNum) ) //15;\n\n```\n\n 参考地址：[CommonJS规范](http://javascript.ruanyifeng.com/nodejs/module.html)\n\n\n\n\n\n\n"},{"title":"原型，原型链和原型链继承","url":"/2020/06/02/原型，原型链和原型链继承/","content":"javaScript里面每一个方法都是一个原型对象(prototype)，该对象都是可扩展的，千言万语不如一行代码；\n例：\n<!-- more -->\n```\n// 所需要的参数\nvar lenoveObj = {\n    \"name\":'联想 Y100',\n    \"address\":\"上海\"\n}\n\nvar dimension = \"100`\";\n\nvar huaweiObj = {\n    \"name\":'huawei P10',\n    \"address\":\"上海\"\n}\n\nvar powerObj = {\n    \"capacity\":'10000mah',\n    \"runtime\":'5day'\n}\n\nvar runsizeObj = {\n    \"name\":\"lenove\",\n    \"runsize\":\"512M\"\n}\n\n// 构造函数\nvar Commodity = function(obj ){\n    this.address = obj.address;\n    this.name = obj.name;\n    this.origin = function( address ){\n        console.log( \"address\", this.address )\n    }\n}\n\n//扩展的方法 price()\nCommodity.prototype.price = function(price){\n    console.log(\"price函数\", price )\n}\n\n// 需要继承构造函数的方法\nvar Computer = function(){}\n\nComputer.prototype = new Commodity(lenoveObj);\n\nComputer.prototype.__prototype__ = Commodity.prototype;\n\n// 扩展的方法 runFn()\nComputer.prototype.runFn = function(runsize){\n    console.log( \"runsize.runsize:\"+runsize.runsize )\n    console.log( \"this.pcWidth:\"+this.pcWidth )\n}\n// 扩展的属性 pcWidth\nComputer.prototype.pcWidth = dimension;\n\n// 需要继承构造函数的方法\nvar Phone = function(){}\n\n// 原型继承 并传入构造函数必要的参数\nPhone.prototype = new Commodity(huaweiObj);\n\n// 原型链继承\nPhone.prototype.__prototype__ = Commodity.prototype;\n\n// 继承之后扩展的方法 powerFn()\nPhone.prototype.powerFn = function(){\n    console.log(\"this.address\",this.address)\n}\n\n//扩展的属性 pingsize\nPhone.prototype.pingsize=\"5`\";\n\n// Phone\nvar huawei = new Phone();\n//查看扩展属性\nconsole.log(\"huawei.name:\",huawei.name);\n//查看自带方法\nhuawei.origin();\n//查看构造函数的扩展方法\nhuawei.price(\"5000\")\n//检测方法继承来源\nconsole.log(huawei instanceof Commodity ) //判断  instanceof 该方法是否继承于某个构造函数\n//查看继承后扩展的方法\nhuawei.powerFn();\n\n\n// Computer\nvar lenove = new Computer();\n//查看继承自Computer构造函数下的runFn方法 传参runsizeObj\nlenove.runFn(runsizeObj);\n```\n"},{"title":"算法失精问题","url":"/2020/06/02/算法失精问题/","content":"浮点数在扩乘100倍时，会出现算法失精；\n最简单的失精例子:\n\n```\n0.1 + 0.2 = 0.30000000000000004\n```\n有时候在处理小数时也会出现这种情况\n比如：\n\n```\n0.007*100 = 0.7000000000000001\n```\n处理办法就是：\n<!-- more -->\n```\n//按照有效数字位数进行四舍五入，默认6位有效数字\nMath.signFigures = function(num, rank = 6) {\n    if(!num) return(0);\n    const sign = num / Math.abs(num);\n    const number = num * sign;\n    const temp = rank - 1 - Math.floor(Math.log10(number));\n    let ans;\n    if (temp > 0) {\n        ans = parseFloat(number.toFixed(temp));\n    } else if (temp < 0) {\n        const temp = Math.pow(10, temp);\n        ans = Math.round(number / temp) * temp;\n    } else {\n        ans = Math.round(number);\n    }\n    return (ans * sign);\n};\n// 实际运用\n0.56 * 100;                    //56.00000000000001\nMath.signFigures(0.56 * 100);  //56\n```\n浮点数算法 https://blog.csdn.net/tercel_zhang/article/details/52537726\n"},{"title":"bootstrap-table一个td使用多个数据","url":"/2020/06/02/bootstrap-table一个td使用多个数据/","content":"在bootstrap-table 里面在定义title 的时候\n\n```\nvar bkDetTit = [\n        {\n        field:'Number',\n        title:'编号',\n        formatter: function( value, row, index ){\n                return index + 1;\n            }\n        },\n        {\n            field:'股票代码',\n            title:'股票代码及行业',\n            formatter:function( value,row,index ){\n\t            //如何使用拿到的多个数据 直接返回拼接好的html;\n                var html = \"<span>\"+row[\"股票代码\"]+\"</span><span>\"+row[\"股票名称\"]+\"</span><span>\"+row[\"所属行业\"]+\"</span>\"\n                return html;\n            }\n        },\n        {\n            field:'起始价格',\n            title:'起始价格',\n            sortable:true\n        },\n        {\n            field:'截止价格',\n            title:'截止价格',\n            sortable:true\n        }\n        ]\n```\n里面有**formatter(value,row,index)**方法可以用来返回多个需要的数据，其中里面有三个参数（value,row,index）;\n**value: 返回该field对应的value**\n**row: 是返回表格的所有数据**\n**index:返回该行数据的下标**\n"},{"title":"js优化-事件委托","url":"/2020/06/02/js优化-事件委托/","content":"**概述：**\n\n那什么叫事件委托呢？它还有一个名字叫事件代理，JavaScript高级程序设计上讲：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。那这是什么意思呢？事件委托基本上，就是取快递来解释这个现象\n\n有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。\n\n这里其实还有2层意思的：\n<!-- more -->\n第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的；\n\n第二，新员工也是可以被前台MM代为签收的，即程序中新添加的dom节点也是有事件的。\n\n**为什么要用事件委托：**\n一般来说，dom需要有事件处理程序，我们都会直接给它设事件处理程序就好了，那如果是很多的dom需要添加事件处理呢？比如我们有100个li，每个li都有相同的click点击事件，可能我们会用for循环的方法，来遍历所有的li，然后给它们添加事件，那这么做会存在什么影响呢？\n\n在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；\n\n每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了（内存不够用，是硬伤，哈哈），比如上面的100个li，就要占用100个内存空间，如果是1000个，10000个呢，那只能说呵呵了，如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了，是不是省了很多，自然性能就会更好。\n\n**事件委托的原理：**\n\n事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div>ul>li>a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a>li>ul>div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。\n\n**事件委托怎么实现：**\n本文的核心部分，在介绍事件委托的方法之前，我们先来看一段一般方法的例子：\n```\n<ul id=\"oul\">\n    <li>111</li>\n    <li>222</li>\n    <li>333</li>\n    <li>444</li>\n</ul>\n```\n实现功能是点击li，弹出123：\n\n```\nwindow.onload = function(){\n    var oUl = document.getElementById(\"oul\");\n    var oLi = oUl.getElementsByTagName('li');\n    for(var i=0;i<aLi.length;i++){\n        oLi[i].onclick = function(){\n            alert(123);\n        }\n    }\n}\n```\n 上面的代码的意思很简单，相信很多人都是这么实现的，我们看看有多少次的dom操作，首先要找到ul，然后遍历li，然后点击li的时候，又要找一次目标的li的位置，才能执行最后的操作，每次点击都要找一次li；\n\n那么我们用事件委托的方式做又会怎么样呢？\n```\nwindow.onload = function(){\n    var oUl = document.getElementById(\"oul\");\n   oUl.onclick = function(){\n        alert(123);\n    }\n}\n```\n这里用父级ul做事件处理，当li被点击时，由于冒泡原理，事件就会冒泡到ul上，因为ul上有点击事件，所以事件就会触发，当然，这里当点击ul的时候，也是会触发的，那么问题就来了，如果我想让事件代理的效果跟直接给节点的事件效果一样怎么办?\n解决办法就是通过事件源 [event.target](http://www.w3school.com.cn/jsref/event_target.asp) 如果是ie则使用 event.srcElement 来代替event.target  定位到事件触发的节点。\n```\nobj = event.srcElement ? event.srcElement : event.target; //兼容IE\n```\n此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用nodeName来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写再做比较（看个人习惯）；\n```\nwindow.onload = function(){\n　　var oUl = document.getElementById(\"ul1\");\n　　oUl.onclick = function(ev){\n　　　　var ev = ev || window.event;\n　　　　var target = ev.target || ev.srcElement;\n　　　　if(target.nodeName.toLowerCase() == 'li'){\n　 　　　　　　 alert(123);\n　　　　　　　  alert(target.innerHTML);\n　　　　}\n　　}\n}\n```\n这样改下就只有点击li会触发事件了，且每次只执行一次dom操作，如果li数量很多的话，将大大减少dom的操作，优化的性能可想而知！\n\n上面的例子是说li操作的是同样的效果，要是每个li被点击的效果都不一样，那么用事件委托还有用吗？\n```\n<div id=\"box\">\n   <input type=\"button\" id=\"add\" value=\"添加\" />\n   <input type=\"button\" id=\"remove\" value=\"删除\" />\n   <input type=\"button\" id=\"move\" value=\"移动\" />\n   <input type=\"button\" id=\"select\" value=\"选择\" />\n</div>\n\nwindow.onload = function(){\n    var Add = document.getElementById(\"add\");\n    var Remove = document.getElementById(\"remove\");\n    var Move = document.getElementById(\"move\");\n    var Select = document.getElementById(\"select\");\n\n    Add.onclick = function(){\n        alert('添加');\n    };\n    Remove.onclick = function(){\n        alert('删除');\n    };\n    Move.onclick = function(){\n        alert('移动');\n    };\n    Select.onclick = function(){\n        alert('选择');\n    }\n\n}\n```\n上面实现的效果我就不多说了，很简单，4个按钮，点击每一个做不同的操作，那么至少需要4次dom操作，如果用事件委托，能进行优化吗？\n```\nwindow.onload = function(){\n    var oBox = document.getElementById(\"box\");\n    oBox.onclick = function (ev) {\n        var ev = ev || window.event;\n        var target = ev.target || ev.srcElement;\n        if(target.nodeName.toLocaleLowerCase() == 'input'){\n            switch(target.id){\n                case 'add' :\n                    alert('添加');\n                    break;\n                case 'remove' :\n                    alert('删除');\n                    break;\n                case 'move' :\n                    alert('移动');\n                    break;\n                case 'select' :\n                    alert('选择');\n                    break;\n            }\n        }\n    }\n}\n```\n用事件委托就可以只用一次dom操作就能完成所有的效果，比上面的性能肯定是要好一些的\n\n\n\n 现在讲的都是document加载完成的现有dom节点下的操作，那么如果是新增的节点，新增的节点会有事件吗？也就是说，一个新员工来了，他能收到快递吗？\n\n看一下正常的添加节点的方法：\n```\n<input type=\"button\" name=\"\" id=\"btn\" value=\"添加\" />\n<ul id=\"ul1\">\n    <li>111</li>\n    <li>222</li>\n    <li>333</li>\n    <li>444</li>\n</ul>\n```\n现在是移入li，li变红，移出li，li变白，这么一个效果，然后点击按钮，可以向ul中添加一个li子节点\n```\nwindow.onload = function(){\n     var oBtn = document.getElementById(\"btn\");\n     var oUl = document.getElementById(\"ul1\");\n     var aLi = oUl.getElementsByTagName('li');\n     var num = 4;\n\n     //鼠标移入变红，移出变白\n     for(var i=0; i<aLi.length;i++){\n         aLi[i].onmouseover = function(){\n             this.style.background = 'red';\n         };\n         aLi[i].onmouseout = function(){\n             this.style.background = '#fff';\n         }\n     }\n     //添加新节点\n     oBtn.onclick = function(){\n         num++;\n         var oLi = document.createElement('li');\n         oLi.innerHTML = 111*num;\n         oUl.appendChild(oLi);\n     };\n }\n```\n这是一般的做法，但是你会发现，新增的li是没有事件的，说明添加子节点的时候，事件没有一起添加进去，这不是我们想要的结果，那怎么做呢？一般的解决方案会是这样，将for循环用一个函数包起来，命名为mHover，如下：\n```\nwindow.onload = function(){\n    var oBtn = document.getElementById(\"btn\");\n    var oUl = document.getElementById(\"ul1\");\n    var aLi = oUl.getElementsByTagName('li');\n    var num = 4;\n\n    function mHover () {\n        //鼠标移入变红，移出变白\n        for(var i=0; i<aLi.length;i++){\n            aLi[i].onmouseover = function(){\n                this.style.background = 'red';\n            };\n            aLi[i].onmouseout = function(){\n                this.style.background = '#fff';\n            }\n        }\n    }\n    mHover ();\n    //添加新节点\n    oBtn.onclick = function(){\n        num++;\n        var oLi = document.createElement('li');\n        oLi.innerHTML = 111*num;\n        oUl.appendChild(oLi);\n        mHover ();\n    };\n}\n```\n虽然功能实现了，看着还挺好，但实际上无疑是又增加了一个dom操作，在优化性能方面是不可取的，那么有事件委托的方式，能做到优化吗？\n```\nwindow.onload = function(){\n    var oBtn = document.getElementById(\"btn\");\n    var oUl = document.getElementById(\"ul1\");\n    var aLi = oUl.getElementsByTagName('li');\n    var num = 4;\n\n    //事件委托，添加的子元素也有事件\n    oUl.onmouseover = function(ev){\n        var ev = ev || window.event;\n        var target = ev.target || ev.srcElement;\n        if(target.nodeName.toLowerCase() == 'li'){\n            target.style.background = \"red\";\n        }\n\n    };\n    oUl.onmouseout = function(ev){\n        var ev = ev || window.event;\n        var target = ev.target || ev.srcElement;\n        if(target.nodeName.toLowerCase() == 'li'){\n            target.style.background = \"#fff\";\n        }\n\n    };\n\n    //添加新节点\n    oBtn.onclick = function(){\n        num++;\n        var oLi = document.createElement('li');\n        oLi.innerHTML = 111*num;\n        oUl.appendChild(oLi);\n    };\n}\n```\n上面是用事件委托的方式，新添加的子元素是带有事件效果的，我们可以发现，当用事件委托的时候，根本就不需要去遍历元素的子节点，只需要给父级元素添加事件就好了，其他的都是在js里面的执行，这样可以大大的减少dom操作，这才是事件委托的精髓所在。\n\n **总结**：\n\n那什么样的事件可以用事件委托，什么样的事件不可以用呢？\n\n适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。\n\n值得注意的是，mouseover和mouseout虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。\n\n不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，在不如说focus，blur之类的，本身就没用冒泡的特性，自然就不能用事件委托了。\n"},{"title":"获取浏览器视口宽高以及元素宽高","url":"/2020/06/02/获取浏览器视口宽高以及元素宽高/","content":"适用所有浏览器\n```javascript\nvar w = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\nvar w = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n```\n有三种方法能够确定浏览器窗口的尺寸（浏览器的视口，不包括工具栏和滚动条）。\n<!-- more -->\n对于Internet Explorer9、Chrome、Firefox、Opera 以及 Safari：\n```javascript\nwindow.innerHeight; // 浏览器窗口的内部高度\nwindow.innerWidth; // 浏览器窗口的内部宽度\n```\n对于 ie 8、7、6、5：\n```javascript\ndocument.documentElement.clientHeight\ndocument.documentElement.clientWidth\n//或者\ndocument.body.clientHeight\ndocument.body.clientWidth\n```\n\n获取页面总高度和宽度，以及scrollTop d的兼容处理；\n```javascript\n// clientWidth 处理兼容性\nfunction getClient() {\n    return {\n        width: window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth,\n        height: window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight\n    }\n}\n// scrollTop兼容性处理\nfunction getScrollTop() {\n    return window.pageYOffset || document.documentElement.scrollTop;\n}\n```\n获取元素的宽高\n```javascript\n// 对应的dom元素的宽高有以下几个常用的：\ndocument.getElementById(\"div\").offsetHeight; // 元素的实际高度\ndocument.getElementById(\"div\").offsetWidth;  // 元素的实际宽度\ndocument.getElementById(\"div\").offsetLeft;  // 元素的实际距离左边界的距离\ndocument.getElementById(\"div\").offsetTop // 元素的实际距离上边界的距离\n```\n"},{"title":"传输中文的乱码的原因及解决方式（两次encodeURI()）转码","url":"/2020/06/02/传输中文的乱码的原因及解决方式（两次encodeURI-）转码/","content":".encodeURL函数主要是来对URI来做转码，它默认是采用的UTF-8的编码.\n. UTF-8编码的格式:一个汉字来三个字节构成，每一个字节会转换成16进制的编码，同时添加上%号.\n\n假设页面端输入的中文是一个 <font color=\"#bf0000\">“中”</font>，按照下面步骤进行解码\n<!-- more -->\n1.第一次encodeURI，**按照utf-8方式获取字节数组变成<font color=\"#bf0000\">[-28,-72-83]</font>，对字节码数组进行遍历，把每个字节转化成对应的16进制数，这样就变成了<font color=\"#bf0000\">[E4,B8,AD]</font>,最后变成<font color=\"#bf0000\">[%E4,%B8,%AD]</font>  此时已经没有了多字节字符，全部是单字节字符。**\n\n2、第二次encodeURI，进行编码，**会把%看成一个转义字符，并不编码%以后字符，会把%编码成%25.把数组最后变成<font color=\"#bf0000\">[%25E4,%25B8,%25AD]</font>然后就把处理后的数据<font color=\"#bf0000\">[%25E4,%25B8,%25AD]</font>发往服务器端，**\n\n当应用服务器调用**getParameter**方法，**getParameter**方法会去向应用服务器请求参数\n\n应用服务器最初获得的就是发送来的<font color=\"#bf0000\">[%25E4,%25B8,%25AD]</font>，应用服务器会对这个数据进行URLdecode操作，应用服务器进行解码的这一次，不管是按照UTF-8，还是GBK，还是ISO-8859，,都能得到<font color=\"#bf0000\">[%E4,%B8,%AD]</font>，因为都会把**%25解析成%**.并把这个值返回给**getParameter方法**;\n\n3、再用UTF-8解码一次，就得到\"中\"了。\n\n想想看，如果不编码两次，当服务器自动解码的时候，假如是按照ISO-8859去解码UTF-8编码的东西，就是会出现乱码。\n\n前端：\n```\n//javascript:\nvar roleName = \"张三\"：\ndocument.authorityForm.action = basePath3+\"User_viewUser.do?id=\"+id+\"&roleName=\"+encodeURI(encodeURI(roleName))+\"&roleType=\"+roleType;\n\n```\n后台：\n```\nroleName = java.net.URLDecoder.decode(getRequest().getParameter(\"roleName\"),\"UTF-8\");\n```\n"},{"title":"利用express+node 建立本地服务器并利用node代理处理跨域请求","url":"/2020/06/02/利用express-node-建立本地服务器并利用node代理处理跨域请求/","content":"第一步 下载安装[node.js](https://nodejs.org/en/)\n第二步 初始化文件夹  命令: npm init\n\t\t\t然后一路回车\n<!-- more -->\n```npm\n  npm init\n```\n[![ttvBLQ.png](https://s1.ax1x.com/2020/06/02/ttvBLQ.png)](https://imgchr.com/i/ttvBLQ)\n第三步 安装express，ejs, request，\n```npm\n\tnpm install express ejs request --save-dev\n```\n[![ttv0sg.png](https://s1.ax1x.com/2020/06/02/ttv0sg.png)](https://imgchr.com/i/ttv0sg)\n\n在初始化文件下新建nodeServer.js(名称自己定义)；\n```\nvar express = require('express');\nvar app = express();\nvar path = require('path');\nvar request = require(\"request\");//request 封装了 HTTP 请求的各种方法，让发起请求变得非常容易；https://www.npmjs.com/package/request\n\n//指定静态资源访问目录\n// app.use(express.static(require('path').join(__dirname, 'views'))); 如果有文件夹存放资源，出现报错的话，那就多use几次就可以了\n// 设定views变量，意为视图存放的目录\napp.use(express.static(require('path').join(__dirname, './items/dist/')));\n\n// 做代理\napp.use('/',function(req,res){\n\t//拿到请求的路径来代理请求，并把响应的结果传给request客户端然后将目标的服务器响应的数据传回浏览器；\n    var url = \"http://localhost:3001\"+req.url;//http://localhost:3001 这里是我后台服务器的端口；\n    req.pipe(request(url)).pipe(res);\n});\n\n// app.set('views', __dirname);\n// 修改模板文件的后缀名为html\napp.set('views', (__dirname + \"./items/dist/\"));\napp.set( 'view engine', 'html' );\n\n// 运行ejs模块\napp.engine( '.html', require( 'ejs' ).__express );\n\napp.get(\"/\", function(req, res) {\n  res.render('index');\n});\n\nvar server = app.listen(8889, \"10.1.1.114\",function(){\n  var host = server.address().address;\n  var port = server.address().port;\n  console.log(\"Server running at http://%s:%s\", host, port)\n});\n\n```\n最后 运行：node  nodeServer.js\n"},{"title":"javascript 原生仿写瀑布流","url":"/2020/06/02/javascript-原生仿写瀑布流/","content":"瀑布流的效果 原理是初始列数top值为0，然后将第一行的高度添加到一个新的数组里，从第二行开始根据储存高度这个数组来，确定最低高度列，然后向最低高度列添加展示数据；\n效果图：\n<!-- more -->\n[![ttjBU1.png](https://s1.ax1x.com/2020/06/02/ttjBU1.png)](https://imgchr.com/i/ttjBU1)\n[![ttjD4x.png](https://s1.ax1x.com/2020/06/02/ttjD4x.png)](https://imgchr.com/i/ttjD4x)\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\" />\n    <title>Document</title>\n<style>\n    * {\n        margin: 0;\n        padding: 0;\n        position: relative;\n    }\n\n    img {\n        width: 220px;\n        display: block;\n    }\n\n    .item {\n        box-shadow: 2px 2px 2px #999;\n        position: absolute;\n    }\n    #box {\n        width: 816px;\n        position: relative;\n    }\n    #box div {\n        position:absolute;\n        width: 198px;\n        border: 1px solid #ddd;\n        margin-left: 4px;\n    }\n\n</style>\n\n</head>\n<body>\n    <div id=\"box\">\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n    </div>\n</body>\n<script type=\"text/javascript\">\n    /**\n     * [ 用来生成瀑布流，不足之处 没有做dom优化在某种极端的情况下，会增加浏览器负担; 待优化 由于是使用定位所以父级是没有高度的]\n     * @return {[type]} [description]\n     *\n     */\n    window.onload= function(){\n        var box = document.getElementById('box');\n        var items = box.getElementsByTagName('div');\n        var url = ''; // 请求地址;\n        var itemCol = 4; // 默认列的间距\n        var itemColGap = 2; // 默认div 上下间的距离；\n        var colNum = 5; // 默认列数;\n        var itemWidth = items[0].offsetWidth; // 获取单个列的宽度；\n\n        // 此处数据只是测试填充；\n        var randomData = []; // 填充数据数组 测试;\n        // 产生随机数\n        function randomHeight(min,max){\n            var min = min;\n            var max = max;\n            var randomVal = Math.ceil(Math.random()*max+min);\n            return randomVal;\n        }\n\n        // 随机数添加到数组并去重；\n        function forData(){\n            if( randomData.length<20 ){\n                var randVal = randomHeight(20,100);\n                if(randomData.indexOf(randVal) < 0 ){\n                    randomData.push(randVal);\n                }\n                forData();\n            }else {\n                return;\n            }\n        }\n        forData(); // 获取随机好的去重数组\n        // 此处数据只是测试填充；--END\n\n        // 初始化\n        pubuFn();\n\n        function pubuFn(){\n            var HeightData = []; // 各个列的初始高度;\n\n            for( var i = 0; i < items.length; i++ ){\n                items[i].style.height = randomData[i]+'px';\n                if( i < colNum){\n                    var getHeightVal = items[i].offsetHeight; // 获取起始高度；\n                    items[i].style.left = i*(itemWidth+itemCol)+'px';\n                    items[i].style.top = 0;\n                    HeightData.push(getHeightVal);\n                } else {\n                    // 获取最低高度值;\n                    var minVal = HeightData[0];\n                    var z = 0;\n                    for( let y=0;y<HeightData.length;y++ ){\n                        if( minVal>HeightData[y] ){\n                            minVal=HeightData[y];\n                            z = y;\n                        }\n                    }\n\n                    items[i].style.top = (HeightData[z]+itemColGap)+'px';\n                    items[i].style.left = (items[z].offsetLeft-itemCol)+'px';\n                    HeightData[z] = items[i].offsetHeight+HeightData[z]+itemColGap; // 每添加一个div 则重新计算初始列高度最低高度;\n                }\n            }\n        }\n\n        // 后续加载数据;\n        window.onscroll = function(event){\n            var crollTop =  document.documentElement.scrollTop || window.pageYOffset;\n            var crollHeihgt = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n            var topSum = crollTop + crollHeihgt;\n            var offsetTopVal = items[items.length-1].offsetTop;\n\n            if( topSum > offsetTopVal){ // 如果滚动条的Top值与视口高度之和 大于 最后一张图片的offsetTop值 那么说明已经到最后一张图片了；\n                // 此处可动态获取数据\n                // todo。。。\n                // 循环添加数据\n                for( var c = 0; c<30;c++ ){\n                    var cHei = randomHeight(0,20);\n                    if( !randomData[cHei] ) continue;\n                    var div = document.createElement('div');\n                    div.style.height= randomData[cHei]+'px';\n                    // 此处可添加需要在div 内添加的内容\n                    // div.innerHTML = '<img src=\"' + datas[i] + '\" alt=\"\">';\n                    div.innerHTML = '<p>'+c+'</p><span>'+c+'</span>';\n                    box.appendChild(div);\n                }\n            }\n            pubuFn() // 每次超过阈值调用;\n        }\n\n    }\n</script>\n</html>\n```\n"},{"title":"HTML5 拖拽","url":"/2020/06/02/HTML5-拖拽/","content":"1、设置元素可拖拽属性；\n```\n\t<img draggable=\"true\">\n```\n<!-- more -->\n2、拖动什么 - ondragstart  设置被拖拽元素 需要传递的数据  需要用onondragstart 来监听事件；\n```\n// html\n...\n<img draggable=\"true\" onondragstart =\"drap(event)\">\n...\n// javascript\n<script>\n...\n\t// dataTransfer.setData(format,data)\n\t// 方法设置被拖数据的数据类型和值\n\t// 参数说明： format 要传递的数据类型；data 传递的数据\n\n\tfunction drap(event){\n\t\t// 具体使用可以看场景而定 也可以自己设置定义的数据 通过全局声明来使用\n\t\tevent.dataTransfer.setData('text',ev.target.id)\n\t}\n<script>\n```\n3、放到何处 - ondragover\nondragover 事件规定在何处放置被拖动的数据。\n默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。\n这要通过调用 ondragover 事件的 event.preventDefault() 方法：\n```\n<div ondragover=\"allowDrop(event)\" ></div>\n// javascript\n<script>\n\t...\n\tfunction allowDrop(event){\n\t\t// 阻止默认事件\n\t\tevent.preventDefault()\n\t}\n<script>\n```\n4、进行放置 - ondrop\n当放置被拖数据时，会发生 drop 事件。ondrop 属性调用了一个函数，drop(event)：\n```\n<div ondragover=\"allowDrop(event)\" ondrop=\"drop(event)\"></div>\n// javascript\n<script>\n\t...\n\tfunction drop(event){\n\t\t// 阻止默认事件\n\t\tevent.preventDefault()\n\t}\n\tfunction allowDrop(event){\n\t\t// 阻止默认事件\n\t\tevent.preventDefault()\n\t}\n<script>\n```\n\n完成的demo\n```\n<!DOCTYPE HTML>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>Html5-拖动</title>\n<style type=\"text/css\">\n#div1 {width:350px;height:70px;padding:10px;border:1px solid #aaaaaa;}\n</style>\n<script>\n\tfunction allowDrop(ev)\n\t{\n\t    ev.preventDefault();\n\t}\n\n\tfunction drag(ev)\n\t{\n\t    ev.dataTransfer.setData(\"Text\",ev.target.id);\n\t}\n\n\tfunction drop(ev)\n\t{\n\t    ev.preventDefault();\n\t    var data=ev.dataTransfer.getData(\"Text\");\n\t    ev.target.appendChild(document.getElementById(data));\n\t}\n</script>\n</head>\n<body>\n\n\t<p>拖动图片到矩形框中:</p>\n\n\t<div id=\"div1\" ondrop=\"drop(event)\" ondragover=\"allowDrop(event)\"></div>\n\n\t<img id=\"drag1\" src=\"/images/logo.png\" draggable=\"true\" ondragstart=\"drag(event)\" width=\"336\" height=\"69\">\n\n</body>\n</html>\n\n\n```\n"},{"title":"获取设备的相应宽高","url":"/2020/06/02/获取设备的相应宽高/","content":"```\n网页可见区域宽： document.body.clientWidth\n网页可见区域高： document.body.clientHeight\n网页可见区域宽： document.body.offsetWidth (包括边线的宽)\n网页可见区域高： document.body.offsetHeight (包括边线的高)\n网页正文全文宽： document.body.scrollWidth\n网页正文全文高： document.body.scrollHeight\n网页被卷去的高： document.body.scrollTop\n网页被卷去的左： document.body.scrollLeft\n网页正文部分上： window.screenTop\n网页正文部分左： window.screenLeft\n屏幕物理分辨率的高： window.screen.height\n屏幕物理分辨率的宽： window.screen.width\n屏幕可用工作区高度： window.screen.availHeight\n屏幕可用工作区宽度： window.screen.availWidth\n屏幕缩放因子：window.devicePixelRatio\n屏幕逻辑分辨率：window.screen.width * window.devicePixelRatio (缩放因子与物理分辨率的乘积)\n```\n"},{"title":"iOS 下键盘唤出后，fixed 元素失效","url":"/2020/06/02/iOS-下键盘唤出后，fixed-元素失效/","content":"遮罩一般要充满全屏，做好的办法就是设置容器position: fixed;\n但是如果遮罩上面的弹框需要输入弹出键盘的话，这时fixed就失效了，比如这种情况\n<!-- more -->\n![ttbRzQ.png](https://s1.ax1x.com/2020/06/02/ttbRzQ.png)\n\n**解决思路**\niOS 下由于软键盘唤出后，页面 fixed 元素会失效，导致跟随页面一起滚动，那么假如页面不会过长出现滚动，那么即便 fixed 元素失效，也无法跟随页面滚动，也就不会出现上面的问题了。\n\n那么按照这个思路，如果使 fixed 元素的父级不出现滚动，而将原 body 滚动的区域域移到 main 内部，而 header 和 footer 的样式不变，代码如下：\n```\n<body class=\"layout-scroll-fixed\">\n    <!-- fixed定位的头部 -->\n    <div class=\"header\">\n\n    </div>\n\n    <!-- 可以滚动的区域 -->\n    <div class=\"main\">\n        <div class=\"content\">\n        <!-- 内容在这里... -->\n        </div>\n    </div>\n\n    <!-- fixed定位的底部 -->\n    <div class=\"footer\">\n        <input type=\"text\" placeholder=\"Footer...\"/>\n        <button class=\"submit\">提交</button>\n    </div>\n</body>\n<style>\n.header {\n    position: fixed;//或者absolute\n    height: 40px;\n    left: 0;\n    right: 0;\n    top: 0;\n}\n.footer {\n    position: fixed;//或者写成absolute\n    height: 30px;\n    left: 0;\n    right: 0;\n    bottom: 0;\n}\n.main {\n/* main绝对定位，进行内部滚动 */\nposition: absolute;\ntop: 40px;\nbottom: 30px;\n/* 使之可以滚动 */\n overflow-y: scroll;\n  /* 增加该属性，可以增加弹性，是滑动更加顺畅 */\n  -webkit-overflow-scrolling: touch;\n}\n\n.main .content {\n    height: 2000px;\n}\n</style>\n```\n"},{"title":"vue组件多选并展示选中顺序","url":"/2020/06/02/vue组件多选并展示选中顺序；/","content":"在公司某些开发场景中需要多选并显示优先级 现记录一下；\n基本思路： 根据Vue.js 的数据绑定，当事件发生时会触发数据的变化来更新数据；\n<!-- more -->\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\" />\n    <title>arrSelect</title>\n</head>\n<script type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n<body>\n<div id=\"app\">\n      <div>\n          <ul>\n              <li v-for=\"(item,index) in tableData\" :key=\"item.index\"><input type=\"checkbox\" @click=\"fn(item,item.checkval)\" :checked=\"item.checkval\" /><span>{{ item.date }}-{{ item.name }}-{{ item.preference }}</span></li>\n          </ul>\n      </div>\n</div>\n</body>\n\n\n<script type=\"text/javascript\">\n    var vue =new Vue({\n        el: \"#app\",\n        data() {\n          return {\n          tableData: [{\n                  date: '2016-05-04',\n                  name: '智立方',\n                  checkval: false,\n                  preference: '',\n                  address: '上海市番禺路868'\n                }, {\n                  date: '2016-05-04',\n                  name: '智立方',\n                  checkval: false,\n                  preference: '',\n                  address: '上海市番禺路868'\n                }, {\n                  date: '2016-05-04',\n                  name: '智立方',\n                  checkval: false,\n                  preference: '',\n                  address: '上海市番禺路868'\n                }, {\n                  date: '2016-05-04',\n                  name: '智立方',\n                  checkval: false,\n                  preference: '',\n                  address: '上海市番禺路868'\n                }, {\n                  date: '2016-05-04',\n                  name: '智立方',\n                  checkval: false,\n                  preference: '',\n                  address: '上海市番禺路868'\n                }],\n                handleArr:[], // 选中的数组\n                handleNum: 0 // 选中的顺序\n              }\n        },\n        methods: {\n          fn(val,status){\n            val.checkval = !status // 再次点击反选字段;\n            if( val.checkval ){ // 根据是否选中来处理相应的选中顺序;\n                this.handleArr.push(val); // 选中则添加到选中数组；\n                val.preference = (this.handleNum<=this.handleArr.length ?  this.handleNum+=1 : this.handleNum = this.handleArr.length); // 根据选中数组的长度来增加选中顺序值；\n            } else {\n                this.handleArr.splice(this.handleArr.indexOf(val),1); // 反选之后删除选中的数组\n                for( let item in this.tableData ){ // 循环绑定的数据来判断顺序值是否需要减少；\n                    if( this.tableData[item].preference>0 && this.tableData[item].preference > val.preference  ){\n                        this.tableData[item].preference --;\n                        this.handleNum--;\n                    }\n                }\n                this.handleNum = this.handleArr.length; // 将同步数组的长度附顺序字段；目的是获取顺序值目前的最大值；\n                val.preference = ''; // 如果是反选则清空顺序值\n            }\n          }\n      }\n })\n</script>\n</html>\n```\n\n个人理解 仅供参考 如有不当 欢迎指正\n"},{"title":"npm install出现: Unexpected end of JSON input while parsing near","url":"/2020/06/02/npm-install出现-Unexpected-end-of-JSON-input-while-parsing-near/","content":"安装node版本管理工具的时候 把node卸载了 然后重新安装了node版本 然后就出现了Unexpected end of JSON input while parsing near  网上各种查，，，，终于解决了\n第一种情况是 最新版的Nodejs与npm版本不合适的问题（因为没更新Node之前是不会的）。\n解决办法就是 把npm的版本降到4版。\n在windows下使用cmd执行语句：**npm -g i npm@4**  或者安装6.x 版本；\n<!-- more -->\nMac系统的就按照相同的思路修改就行啦，btw\n[具体原因看这里](https://blog.csdn.net/weixin_41902031/article/details/80041000)\n\n第二种情况是 因为npm存在缓存导致 无法安装\n在cmd下（windows）执行：**npm cache clean --force**\n\n还有一种情况是我个人遇到的\n\t在nrm下使用taobao的npm链接也会报上面的错误\n\t**解决办法就是:使用npm 而不使用淘宝的镜像**\n\n\n"},{"title":"使用xlsx.full.min.js处理excel表格（主要将数据转化为excel表并实现下载）","url":"/2020/06/02/使用xlsx-full-min-js处理excel表格（主要将数据转化为excel表并实现下载）/","content":"需要文件[xlsx.full.min.js](https://github.com/SheetJS/js-xlsx/tree/master/dist)\n<!-- more -->\n```\n<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset=\"UTF-8\">\n    <title></title>\n    <script src=\"./xlsx.full.min.js\"></script>\n</head>\n\n<body>\n    <button onclick=\"downloadExl(jsono)\">导出</button>\n    <!--\n            以下a标签不需要内容\n        -->\n    <a href=\"\" download=\"这里是下载的文件名.xlsx\" id=\"hf\"></a>\n    <script>\n        var jsono = [{ //测试数据\n            \"保质期临期预警(天)\": \"adventLifecycle\",\n            \"商品标题\": \"title\",\n            \"建议零售价\": \"defaultPrice\",\n            \"高(cm)\": \"height\",\n            \"商品描述\": \"Description\",\n            \"保质期禁售(天)\": \"lockupLifecycle\",\n            \"商品名称\": \"skuName\",\n            \"商品简介\": \"brief\",\n            \"宽(cm)\": \"width\",\n            \"阿达\": \"asdz\",\n            \"货号\": \"goodsNo\",\n            \"商品条码\": \"skuNo\",\n            \"商品品牌\": \"brand\",\n            \"净容积(cm^3)\": \"netVolume\",\n            \"是否保质期管理\": \"isShelfLifeMgmt\",\n            \"是否串号管理\": \"isSNMgmt\",\n            \"商品颜色\": \"color\",\n            \"尺码\": \"size\",\n            \"是否批次管理\": \"isBatchMgmt\",\n            \"商品编号\": \"skuCode\",\n            \"商品简称\": \"shortName\",\n            \"毛重(g)\": \"grossWeight\",\n            \"长(cm)\": \"length\",\n            \"英文名称\": \"englishName\",\n            \"净重(g)\": \"netWeight\",\n            \"商品分类\": \"categoryId\",\n            \"这里超过了\": 1111.0,\n            \"保质期(天)\": \"expDate\"\n        }];\n        var tmpDown; //导出的二进制对象\n        function downloadExl(json, type) {\n            var tmpdata = json[0];\n            json.unshift({});\n            var keyMap = []; //获取keys\n            //keyMap =Object.keys(json[0]);\n            for (var k in tmpdata) {\n                keyMap.push(k);\n                json[0][k] = k;\n            }\n          var tmpdata = [];//用来保存转换好的json\n                json.map((v, i) => keyMap.map((k, j) => Object.assign({}, {\n                    v: v[k],\n                    position: (j > 25 ? getCharCol(j) : String.fromCharCode(65 + j)) + (i + 1)\n                }))).reduce((prev, next) => prev.concat(next)).forEach((v, i) => tmpdata[v.position] = {\n                    v: v.v\n                });\n                var outputPos = Object.keys(tmpdata); //设置区域,比如表格从A1到D10\n                var tmpWB = {\n                    SheetNames: ['mySheet'], //保存的表标题\n                    Sheets: {\n                        'mySheet': Object.assign({},\n                            tmpdata, //内容\n                            {\n                                '!ref': outputPos[0] + ':' + outputPos[outputPos.length - 1] //设置填充区域\n                            })\n                    }\n                };\n                tmpDown = new Blob([s2ab(XLSX.write(tmpWB,\n                    {bookType: (type == undefined ? 'xlsx':type),bookSST: false, type: 'binary'}//这里的数据是用来定义导出的格式类型\n                    ))], {\n                    type: \"\"\n                }); //创建二进制对象写入转换好的字节流\n            var href = URL.createObjectURL(tmpDown); //创建对象超链接\n            document.getElementById(\"hf\").href = href; //绑定a标签\n            document.getElementById(\"hf\").click(); //模拟点击实现下载\n            setTimeout(function() { //延时释放\n                URL.revokeObjectURL(tmpDown); //用URL.revokeObjectURL()来释放这个object URL\n            }, 100);\n        }\n\n        function s2ab(s) { //字符串转字符流\n            var buf = new ArrayBuffer(s.length);\n            var view = new Uint8Array(buf);\n            for (var i = 0; i != s.length; ++i) view[i] = s.charCodeAt(i) & 0xFF;\n            return buf;\n        }\n         // 将指定的自然数转换为26进制表示。映射关系：[0-25] -> [A-Z]。\n        function getCharCol(n) {\n            let temCol = '',\n            s = '',\n            m = 0\n            while (n > 0) {\n                m = n % 26 + 1\n                s = String.fromCharCode(m + 64) + s\n                n = (n - m) / 26\n            }\n            return s\n        }\n    </script>\n</body>\n\n</html>\n\n```\n*** 说明：导出示例的测试数据已经含有表头了如果没有表头可以直接将json中的遍历第一条数据的key创建一个value=key（{key:key}）插入到json第一条就可以了***\n"},{"title":"利用xlsl.full.js导入excel表格","url":"/2020/06/02/利用xlsl-full-js导入excel表格/","content":"需要的文件 [xlsx.full.min.js](https://github.com/SheetJS/js-xlsx/tree/master/dist)\n```\n<!DOCTYPE html>\n<html>\n\n    <head>\n        <meta charset=\"UTF-8\">\n        <title></title>\n        <script src=\"./xlsx.full.min.js\"></script>\n    </head>\n\n    <body>\n        <input type=\"file\"onchange=\"importf(this)\" />\n        <div id=\"demo\"></div>\n        <script>\n            /*\n            FileReader共有4种读取方法：\n            1.readAsArrayBuffer(file)：将文件读取为ArrayBuffer。\n            2.readAsBinaryString(file)：将文件读取为二进制字符串\n            3.readAsDataURL(file)：将文件读取为Data URL\n            4.readAsText(file, [encoding])：将文件读取为文本，encoding缺省值为'UTF-8'\n                         */\n            var wb;//读取完成的数据\n            var rABS = false; //是否将文件读取为二进制字符串\n\n            function importf(obj) {//导入\n                if(!obj.files) {\n                    return;\n                }\n                var f = obj.files[0];\n                var reader = new FileReader();\n                reader.onload = function(e) {\n                    var data = e.target.result;\n                    if(rABS) {\n                        wb = XLSX.read(btoa(fixdata(data)), {//手动转化\n                            type: 'base64'\n                        });\n                    } else {\n                        wb = XLSX.read(data, {\n                            type: 'binary'\n                        });\n                    }\n                    //wb.SheetNames[0]是获取Sheets中第一个Sheet的名字\n                    //wb.Sheets[Sheet名]获取第一个Sheet的数据\n                    document.getElementById(\"demo\").innerHTML= JSON.stringify( XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]]) );\n                };\n                if(rABS) {\n                    reader.readAsArrayBuffer(f);\n                } else {\n                    reader.readAsBinaryString(f);\n                }\n            }\n\n            function fixdata(data) { //文件流转BinaryString\n                var o = \"\",\n                    l = 0,\n                    w = 10240;\n                for(; l < data.byteLength / w; ++l) o += String.fromCharCode.apply(null, new Uint8Array(data.slice(l * w, l * w + w)));\n                o += String.fromCharCode.apply(null, new Uint8Array(data.slice(l * w)));\n                return o;\n            }\n\n        </script>\n    </body>\n\n</html>\n\n```\n"},{"title":"Mac下安装nvm及常见问题","url":"/2020/06/02/Mac下安装nvm及常见问题/","content":"转 [Mac下安装nvm及常见问题](https://www.jianshu.com/p/04d31f6c22bd)\n前言：(这一步是可选，如果是windows 用户最好是删除已安装的node和npm)\n1.卸载已安装到全局的 node/npm\n    如果之前是在官网下载的 node 安装包，运行后会自动安装在全局目录，其中\n```\nnode 命令在 /usr/local/bin/node ，npm 命令在全局 node_modules 目录中，具体路径为 /usr/local/lib/node_modules/npm\n```\n\n安装 nvm 之后最好先删除下已安装的 node 和全局 node 模块：\n\n<!-- more -->\n\n**一、安装**\n\t1、curl 安装\n\t```\n\t\tcurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash\n\t```\n\t或者 wget\n\t```\n\t\twget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash\n\t```\n\t具体版本查看地址\n\t\thttps://github.com/creationix/nvm/blob/master/README.md\n安装完成后请重新打开终端环境\n2、查看安装\n\t安装完 nvm 后，输入nvm，当看到有输出时，则 nvm 安装成功。\n\t```\n\t\tnvm: command not found\n\t```\n\t编辑.bash_profile文件，没有的话就新建一个，\n>1. 启动终端Terminal\n>2. 进入当前用户的home目录\n>输入cd ~\n>3. 创建.bash_profile\n>输入touch .bash_profile\n>4. 编辑.bash_profile文件\n>输入open .bash_profile\n>第一种方式\n><1>、为在弹出的.bash_profile文件内进行编辑\n><2>、编辑完成后直接保存文件\n><3>、关闭.bash_profile文件\n><4>、更新配置过的环境变量    输入source .bash_profile\n><5>、 启动终端Terminal\n>\t\t第二种方式来编辑.bash_profile文件\n>在Terminal终端通过指令来对.bash_profile文件进行编辑\n><1>、输入 vim .bash_profile\n><2>、输入 i 进行编辑模式\n><3>、然后把需要编辑的内容键入，编辑完之后直接按esc退出编辑模式，\n><4>、输入:w进行文件的保存，:wq为保存并退出指令\n\n\n**二、 使用**\n\n```\nnvm install stable # 安装最新稳定版 node，现在是 5.0.0\nnvm install 4.2.2 # 安装 4.2.2 版本\nnvm install 0.12.7 # 安装 0.12.7 版本\n\n# 特别说明：以下模块安装仅供演示说明，并非必须安装模块\nnvm use 4 # 切换至 4.2.2 版本\nnpm install -g mz-fis # 安装 mz-fis 模块至全局目录，安装完成的路径是 /Users/<你的用户名>/.nvm/versions/node/v0.12.7/lib/mz-fis\nnvm use 0 # 切换至 0.12.7 版本\nnpm install -g react-native-cli #安装 react-native-cli 模块至全局目录，安装完成的路径是 /Users/<你的用户名>/.nvm/versions/node/v4.2.2/lib/react-native-cli\n\nnvm alias default 0.12.7 #设置默认 node 版本为 0.12.7\n\n```\n查看nvm版本：打开新的终端，用nvm current查看当前版本显示\n\n删除指定版本 node：nvm uninstall v6.6.0\n\nnvm 提供了 nvm use 命令。这个命令的使用方法和 install 命令类似。\n```\n例如，切换到 4.2.2：\nnvm use 4.2.2\n切换到最新的 `4.2.x``：\nnvm use 4.2\n切换到最新版：\nnvm use node\n```\n我们还可以用 nvm 给不同的版本号设置别名：\n\n```\n我们给 4.2.2 这个版本号起了一个名字叫做 awesome-version\nnvm alias awesome-version 4.2.2\n\n然后我们可以运行：\nnvm use awesome-version\n\n下面这个命令可以取消别名：\nnvm unalias awesome-version\n\n另外，你还可以设置 default 这个特殊别名：\nnvm alias default node\n```\n列出已安装实例\n```\nnvm ls\n```\n"},{"title":"栈和队列理解","url":"/2020/06/02/栈和队列理解/","content":"栈 就是先进后出FILO (First-In-Last-Out); 像一个杯子 喝到的始终是最上面的水；\n队列 就是 先进先出FIFO(First-In-Lsat-Out); 像吸管喝到的始终是底部的水；\n<!-- more -->\n```javascript\n// 栈 先进后出 First-In-Last-Out\n/**\n * push() 进来 向尾部添加数据\n *      |  2  |\n *      |  1  |\n *      |     |\n *      |     |\n *      |_____|\n *\n *\n * pop() 出去 先删除尾部数据\n *\n *\n *      |  1  |\n *      |     |\n *      |     |\n *      |_____|\n *\n */\n\nvar stackArr = ['a'];\n\nstackArr.push('b');\nstackArr.push('c');\n\nconsole.log('stackArr-',stackArr) // stackArr-['a','b','c'];\n\nstackArr.pop();\n\nconsole.log('stackArr-',stackArr) // stackArr-['a','b'];\n\nstackArr.pop();\n\nconsole.log('stackArr-',stackArr) // stackArr-['a'];\n\n// 队列 先进先出 First-In-Fisrt-Out\n/**\n * unshift() 进来 向底部添加数据\n *      |     |\n *      |     |\n *      |     |\n *      |  2  |\n *      |  1  |\n *\n *\n * shift() 出去 底部的‘1’ 先删除\n *\n *      |     |\n *      |     |\n *      |     |\n *      |  2  |\n *\n */\nvar queueList = ['a'];\n\nqueueList.unshift('b','c');\n\nconsole.log('queueList-',queueList); // queueList-['b','c','a']\n\nqueueList.shift();\n\nconsole.log('queueList-',queueList); // queueList-['c','a']\n\nqueueList.shift();\n\nconsole.log('queueList-',queueList); // queueList-['a']\n```\n"},{"title":"使用mockjs 模拟前后台交互","url":"/2020/06/02/使用mockjs-模拟前后台交互/","content":"使用背景： vue项目 axios\n使用详情：\n1、首先安装\n```javascript\n\t# 在项目中安装\n    npm install mockjs\n```\n2、在项目中使用\n在项目中src文件夹下 新建mock文件夹 新建mock.js 和index.js文件 这里面用来生成基础的接口\n项目结构截图：\n![tt54qf.png](https://s1.ax1x.com/2020/06/02/tt54qf.png)\n数据\n<!-- more -->\nmock.js 文件\n```javascript\n//-----------------mock.js-------------------\n// 引入mockjs\nimport Mock from 'mockjs'\n\n// 创建模拟数据 具体的数据生成方法 请查看文档http://mockjs.com/examples.html\nfunction creatPostMock () {\n  const list = []\n  const mockdata = {\n    id: '@increment', // 数据定义 @increment\n    'object|1': {\n      '310000': '上海市',\n      '320000': '江苏省',\n      '330000': '浙江省',\n      '340000': '安徽省'\n    },\n    name: '@pick([\"a\", \"e\", \"i\", \"o\", \"u\"])',\n    m1: '@integer(60, 100)',\n    m2: '@integer(60, 100)',\n    m3: '@integer(60, 100)',\n    m4: '@integer(60, 100)',\n    m5: '@integer(60, 100)',\n    m6: '@integer(60, 100)',\n    m7: '@integer(60, 100)',\n    m8: '@integer(60, 100)',\n    m9: '@integer(60, 100)'\n  }\n  for (var i = 0; i < 10; i++) {\n    const a = Mock.mock(mockdata)\n    list.push(a)\n  }\n  const data = {\n    data: {},\n    size: 1,\n    pagesize: 10\n  }\n  data.data = list\n  return data\n}\n\n// 创建模拟数据\nfunction creatGetMock () {\n  const getMock = Mock.mock({\n    'list|1-10': [{\n      'id|+1': 1\n    }]\n  })\n  return getMock\n}\n\n// 将模拟好的数据输出出去；\nexport {creatPostMock, creatGetMock}\n```\nindex.js 文件\n```javascript\n// ------------index.js---------------\n// 引入mockjs\nimport Mock from 'mockjs'\n// 引入生成的模拟数据\nimport {creatPostMock, creatGetMock} from './mock'\n\n// 设置请求延时时间\nMock.setup({\n  // timeout: 2000 方式一 直接设置值\n  timeout: '2000 - 5000' // 方式二 设置区间 注意这个是一个字符串形式\n})\n\n// 设置拦截的接口 格式请看文档 https://github.com/nuysoft/Mock/wiki/Mock.mock()\n// 注意: 这里拦截的地址 最好使用正则匹配 如果直接使用字符串接口 就有可能拦截不到带参数的请求 报错404\nMock.mock(/\\/api\\/mock(|\\?\\S*)$/, 'post', creatPostMock)\n// Mock.mock('/api/mock', 'get', creatGetMock) // 方式一\nMock.mock(/\\/api\\/mock(|\\?\\S*)$/, 'get', creatGetMock) // 方式二\n```\n然后在main.js 文件里面引入我们写好的mock/index.js文件 用于拦截请求\n```javascript\n//------------------main.js-------------------\n// The Vue build version to load with the `import` command\n// (runtime-only or standalone) has been set in webpack.base.conf with an alias.\nimport Vue from 'vue'\nimport App from './App'\nimport router from './router'\nimport axios from 'axios' // 引入axios\nimport('./mock/index') // 引入设置好基础的mock, 用于拦截请求\n\n// 设置为 false 以阻止 vue 在启动时生成生产提示。\nVue.config.productionTip = false\n\n// 在vue项目中 axios中无法直接使用vue.use() 所以将axios直接添加到Vue的原型上\nVue.prototype.axios = axios\n\n/* eslint-disable no-new */\nnew Vue({\n  el: '#app',\n  router,\n  components: { App },\n  template: '<App/>'\n})\n```\n接下来我们就可以定义api了 在api文件下 新建一个自定义接口文件 如questMock.js 里面是我们需要请求数据的模拟接口；\n```javascript\n//-------------questMock.js----------------\n// 引入axios\nimport axios from 'axios'\n// 使用\nthis.axios = axios\n// 封装的post\nfunction postMockList (data) {\n  return this.axios.post('/api/mock', {\n    data\n  })\n}\n// 封装的get\nfunction getMockList (data) {\n  return this.axios.get('/api/mock', {\n    data\n  })\n}\n// 输出\nexport { postMockList, getMockList }\n```\n最后在组件中使用\n```javascript\n// ----------------------HelloWorld---------------------\n<template>\n  <div class=\"hello\">\n    <div class=\"mask\" :class=\"{boxNone:isMask }\"></div>\n    <div>\n      <p>这是获取mock 数据</p>\n      <button @click=\"getMockData\">get模拟数据</button>\n      <button @click=\"postMockData\">post模拟数据</button>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { postMockList, getMockList } from '../api/questMock.js'\nexport default {\n  name: 'HelloWorld',\n  data () {\n    return {\n      msg: '模拟前后台交互',\n      getMock: getMockList,\n      postMock: postMockList,\n      isMask: true\n    }\n  },\n  methods: {\n    getMockData () {\n      this.isMask = false\n      this.getMock({\n        params: {\n          name: '隔壁老王'\n        }\n      }).then(res => {\n        this.isMask = true\n        console.log('GET模拟数据', res)\n      }).catch(e => {\n        console.log('错误', e)\n      })\n    },\n    postMockData () {\n      this.isMask = false\n      this.postMock({\n        name: 'xiaoming',\n        age: '5'\n      }).then(res => {\n        this.isMask = true\n        console.log('POST模拟数据', res)\n      }).catch(e => {\n        console.log('错误', e)\n      })\n    }\n  }\n}\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped>\nh1, h2 {\n  font-weight: normal;\n}\nul {\n  list-style-type: none;\n  padding: 0;\n}\nli {\n  display: inline-block;\n  margin: 0 10px;\n}\na {\n  color: #42b983;\n}\n.mask {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 1000;\n  background-color: green;\n  opacity: 0.5;\n}\n.mask.boxNone {\n  display: none;\n}\n</style>\n```\n遇到的问题\n1、在设置模拟接口时 使用get请求 发现报错404 后来查资料发现是因为直接使用字符串接口会导致mockjs 拦截不到地址  **解决办法就是使用 正则去匹配请求接口**\n2、如何设置请求延时 由于mockjs 是在本地模拟数据所以并未发起真正的请求，无法看到请求的加载效果，**解决办法就是使用Mock.setup({timeout: 加载时间}) 来设置每次的模拟请求时间**\n也可参考以下：\n [vue-cli 中使用 Mockjs ](https://segmentfault.com/a/1190000014844604).\n  [服务器端数据模拟，支持请求转发、返回JSON静态数据、返回JS可变数据 ](https://github.com/Yakima-Teng/mock-server).\n"},{"title":"使用canvas制作背景水印","url":"/2020/06/02/使用canvas制作背景水印/","content":"记录使用canvas 制作文字背景水印\n<!-- more -->\n```javascript\n// 首先创建canvas标签 并设置画布大小\n      var watchCanvas = document.createElement('canvas'); // 创建canvas标签\n      watchCanvas.id = 'myCanvas'; // 设置canvas id名\n      watchCanvas.width = '300'; // 设置画布大小\n      watchCanvas.height = '120';\n      watchCanvas.style.display = 'none'; // 隐藏画布\n      document.documentElement.appendChild(watchCanvas); // 将画布插入到document中\n\n      // 创建 画布内容\n      var c = document.getElementById('myCanvas'); // 获取画布\n\n      // 获取画布上下文\n      var ctx = c.getContext('2d');\n\n      // 设置字体文字大小及字体类型\n      ctx.font = '20px Arial';\n\n      // 设置旋转角度 格式 (-45 * Math.PI) / 180\n      ctx.rotate((-45 * Math.PI) / 180);\n\n      // 设置水印实心文字及偏移量 fillText(text, x, y) strokeText(text,x,y)  说明 text | 在画布上出现的值, x 在x方向上的值(相对于画布), y 在y方向上的值(相对于画布);\n      ctx.fillText('Hello Word', -40, 80);\n      ctx.fillText('canvas', 30, 160);\n\n      // 生成base64格式的图片路径\n      var curl = c.toDataURL('image/png');\n\n      // 将图片作为背景样式插入\n      document.querySelector('.container').style.background =\n        '#bf0000 url(' + curl + ')';\n\n      // 设置水印文字旋转偏移量时 注意是先旋转在偏移 这个时候的偏移量是以偏转之后的坐标轴为基础的\n      // toDataURL(type, encoderOptions) 方法 type | 可选 默认值为'image/png', encoderOptions | 可选 在指定图片格式为 image/jpeg 或 image/webp的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 0.92。其他参数会被忽略。\n```\n"},{"title":"vue2.0 render()渲染函数及jsx","url":"/2020/06/02/vue2-0-render-渲染函数及jsx/","content":"render()函数通过虚拟DOM 来渲染页面\n>因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，及其子节点。我们把这样的节点描述为“虚拟节点 (Virtual Node)”，也常简写它为“VNode”。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t--来源：https://cn.vuejs.org/v2/guide/render-function.html#%E8%99%9A%E6%8B%9F-DOM\n<!-- more -->\n```javascript\ncreateElement()函数用来生成模板：\n参数说明：\ncreateElement(\n// @returns {VNode}\ncreateElement(\n  // {String | Object | Function}\n  // 一个 HTML 标签字符串，组件选项对象，或者\n  // 解析上述任何一种的一个 async 异步函数。必需参数。\n  'div',\n\n  // {Object}\n  // 一个包含模板相关属性的数据对象\n  // 你可以在 template 中使用这些特性。可选参数。\n  {\n    // 和`v-bind:class`一样的 API\n  // 接收一个字符串、对象或字符串和对象组成的数组\n\t  'class': {\n\t    foo: true,\n\t    bar: false\n\t  },\n\t  // 和`v-bind:style`一样的 API\n\t  // 接收一个字符串、对象或对象组成的数组\n\t  style: {\n\t    color: 'red',\n\t    fontSize: '14px'\n\t  },\n\t  // 普通的 HTML 特性\n\t  attrs: {\n\t    id: 'foo'\n\t  },\n\t  // 组件 props\n\t  props: {\n\t    myProp: 'bar'\n\t  },\n\t  // DOM 属性\n\t  domProps: {\n\t    innerHTML: 'baz'\n\t  },\n\t  // 事件监听器基于 `on`\n\t  // 所以不再支持如 `v-on:keyup.enter` 修饰器\n\t  // 需要手动匹配 keyCode。\n\t  on: {\n\t    click: this.clickHandler\n\t  },\n\t  // 仅用于组件，用于监听原生事件，而不是组件内部使用\n\t  // `vm.$emit` 触发的事件。\n\t  nativeOn: {\n\t    click: this.nativeClickHandler\n\t  },\n\t  // 自定义指令。注意，你无法对 `binding` 中的 `oldValue`\n\t  // 赋值，因为 Vue 已经自动为你进行了同步。\n\t  directives: [\n\t    {\n\t      name: 'my-custom-directive',\n\t      value: '2',\n\t      expression: '1 + 1',\n\t      arg: 'foo',\n\t      modifiers: {\n\t        bar: true\n\t      }\n\t    }\n\t  ],\n\t  // 作用域插槽格式\n\t  // { name: props => VNode | Array<VNode> }\n\t  scopedSlots: {\n\t    default: props => createElement('span', props.text)\n\t  },\n\t  // 如果组件是其他组件的子组件，需为插槽指定名称\n\t  slot: 'name-of-slot',\n\t  // 其他特殊顶层属性\n\t  key: 'myKey',\n\t  ref: 'myRef',\n\t  // 如果你在渲染函数中向多个元素都应用了相同的 ref 名，\n\t  // 那么 `$refs.myRef` 会变成一个数组。\n\t  refInFor: true\n  },\n\n  // {String | Array}\n  // 子虚拟节点 (VNodes)，由 `createElement()` 构建而成，\n  // 也可以使用字符串来生成“文本虚拟节点”。可选参数。\n  [\n    '先写一些文字',\n    createElement('h1', '一条数据'),\n    createElement(MyComponent, {\n      props: {\n        someProp: 'foobar'\n      }\n    })\n  ]\n)\n)\n```\n例：\n```javascript\nrender(h){\n\treturn h(\n\t'div',\n\t{\n\t  'class': {\n        foo: true,\n        bar: false\n      },\n      style: {\n        // color: 'red',\n        fontSize: '14px',\n        width: '100px',\n        // height: '20px',\n        backgroundColor: '#bf0000'\n      },\n      attrs: {\n        id: 'foo'\n      },\n      // 需要手动匹配 keyCode。\n      on: {\n        click: bindclickFun\n      },\n    },\n    [\n      '一些内容',\n      createElement('h1', '一条文字')\n    ]\n  )\n}\n```\n\njsx  参考：https://www.jianshu.com/p/feede4445142\n例：\n```javascript\n// ------data\nranderProp:[\n        {\n          prop: 'month',\n          label: '日期'\n        },\n        {\n          prop: 'district',\n          label: '区域'\n        },\n        {\n          prop: 'starLevel',\n          label: '星级'\n        },\n        {\n          prop: 'maturity',\n          label: '校区成熟属性'\n        },\n        {\n          prop: 'teacherName',\n          label: '班主任'\n        },\n        { prop: 'validStudentLast', label: '上月活跃人数' },\n        { prop: 'newStudent', label: '本月新生人数' },\n        { prop: 'leaveStudent', label: '本月CR流失人数', width: 135 },\n        { prop: 'validStudent', label: '本月活跃人数' },\n        { prop: 'courseNum', label: '续费科目数' },\n        { prop: 'studentNum', label: '续费人次数' },\n        { prop: 'validCourseLast', label: '上月活跃科目数', width: 116 },\n        { prop: 'validCourse', label: '本月活跃科目' },\n        { prop: 'addSubject', label: '扩科数' },\n        { prop: 'addSubjectRate', label: '扩科续科率', filter: 'rate' },\n        { prop: 'validCourseAvg', label: '活跃人均科目数', width: 116 },\n        { prop: 'referralPeopleNum', label: '转介绍人次数' },\n        { prop: 'deposit', label: '定金' },\n        { prop: 'signNum', label: '签单数' },\n        { prop: 'inPerformance', label: '业绩' },\n        { prop: 'outPerformance', label: '退费' },\n        { prop: 'performance', label: '净业绩' }\n      ],\n        renderData: [\n            {\n              addSubject: 0.0,\n              addSubjectRate: 0.0,\n              courseNum: 0.0,\n              deposit: 0.0,\n              inPerformance: 8660.0,\n              leaveStudent: 0.0,\n              maturity: '成熟校区',\n              month: '2019-01-01',\n              newStudent: 0.0,\n              outPerformance: 0.0,\n              performance: 8660.0,\n              referralPeopleNum: 0.0,\n              signNum: 1.0,\n              starLevel: '五星校区',\n              studentNum: 1.0,\n              teacherName: '小二',\n              validCourse: 0.0,\n              validCourseAvg: 0.0,\n              validCourseLast: 0.0,\n              validStudent: 0.0,\n              validStudentLast: 0.0\n            },\n            {\n              addSubject: 0.0,\n              addSubjectRate: 0.0,\n              courseNum: 0.0,\n              deposit: 0.0,\n              inPerformance: 0.0,\n              leaveStudent: 0.0,\n              maturity: '成熟校区',\n              month: '2019-01-01',\n              newStudent: 0.0,\n              outPerformance: 0.0,\n              performance: 0.0,\n              referralPeopleNum: 0.0,\n              signNum: 0.0,\n              starLevel: '五星校区',\n              studentNum: 0.0,\n              teacherName: '王五',\n              validCourse: 0.0,\n              validCourseAvg: 0.0,\n              validCourseLast: 0.0,\n              validStudent: 0.0,\n              validStudentLast: 0.0\n            },\n            {\n              addSubject: 0.0,\n              addSubjectRate: 0.0,\n              courseNum: 0.0,\n              deposit: 0.0,\n              inPerformance: 0.0,\n              leaveStudent: 15.0,\n              maturity: '成熟校区',\n              month: '2019-01-01',\n              newStudent: 0.0,\n              outPerformance: 0.0,\n              performance: 0.0,\n              referralPeopleNum: 1.0,\n              signNum: 0.0,\n              starLevel: '五星校区',\n              studentNum: 0.0,\n              teacherName: '张三',\n              validCourse: -30.0,\n              validCourseAvg: 2.0,\n              validCourseLast: 0.0,\n              validStudent: -15.0,\n              validStudentLast: 0.0\n            },\n            {\n              addSubject: 0.0,\n              addSubjectRate: 0.0,\n              courseNum: 0.0,\n              deposit: 0.0,\n              inPerformance: 15470.0,\n              leaveStudent: 15.0,\n              maturity: '成熟校区',\n              month: '2019-01-01',\n              newStudent: 0.0,\n              outPerformance: 0.0,\n              performance: 15470.0,\n              referralPeopleNum: 1.0,\n              signNum: 1.0,\n              starLevel: '五星校区',\n              studentNum: 1.0,\n              teacherName: '陈四',\n              validCourse: -60.0,\n              validCourseAvg: 4.0,\n              validCourseLast: 0.0,\n              validStudent: -15.0,\n              validStudentLast: 0.0\n            },\n\n          ]\n\nrender(){\n\treturn (\n        <el-table data={this.renderData}>\n          {this.randerProp.map(item=>{\n            if(item.prop == 'teacherName'){\n              return <el-table-column prop={item.prop} label={item.label} header-align=\"center\" align=\"center\" {...{scopedSlots:{\n              default:(props)=>{\n                if( props.row.teacherName == '陈四'){\n                  return h('el-button', {props:{type:'primary'}}, ['按钮'])\n                } else {\n                  return props.row.teacherName\n                }\n              }\n            }}}></el-table-column>\n            } else {\n              return <el-table-column prop={item.prop} label={item.label} show-overflow-tooltip header-align=\"center\" align=\"center\" ></el-table-column>\n            }\n          })}\n        </el-table>\n\t)\n}\n```\n"},{"title":"vue2.0 组件复用 数据没有更新","url":"/2020/06/02/vue2-0-组件复用-数据没有更新/","content":"如果开发过程中出现使用**v-if-else**来切换组件时发现数据没有更新，那么就是因为元素被复用具体可以[参考vue官网-组件]( https://cn.vuejs.org/v2/guide/conditional.html#%E7%94%A8-key-%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%85%83%E7%B4%A0)\n```javascript\n<template v-if=\"loginType === 'username'\">\n  <input placeholder=\"Enter your username\">\n</template>\n<template v-else>\n  <input placeholder=\"Enter your email address\">\n</template>\n```\n<!-- more -->\n查看input元素发现只有input的placeholder的变化了 元素本身就没有改变，而且输入的值也没有被清除；原因是vue为了尽快的渲染页面所以通常会复用已经渲染的元素，所以会导致绑定的数据并没被实时刷新；\n解决办法就是：对复用的元素添加 **key**\n\n```javascript\n<template v-if=\"loginType === 'username'\">\n  <input placeholder=\"Enter your username\" key=\"username-input\">\n</template>\n<template v-else>\n  <input placeholder=\"Enter your email address\" key=\"email-input\">\n</template>\n```\n这样就避免了数据没有刷新的问题\n"},{"title":"正则匹配身份证号","url":"/2020/06/02/正则匹配身份证号/","content":"正则匹配身份证号 分为18位和15位\n首先写正则之前我们先明白身份证号的结构 18位\n```\n地区： ([1-6][1-9]|50)\\d{4}  // 补充重庆地区50\n年的前两位： (18|19|20)            1800-2399\n年的后两位： \\d{2}\n月份：((0[1-9])|10|11|12)\n天数： (([0-2][1-9])|10|20|30|31)      闰年不能禁止29+\n三位顺序码： \\d{3}\n校验码： [0-9Xx]\n// 校验18位的身份证\nlet _IDRe18 =  /^([1-6][1-9]|50)\\d{4}(18|19|20)\\d{2}((0[1-9])|10|11|12)(([0-2][1-9])|10|20|30|31)\\d{3}[0-9Xx]$/\n```\n<!-- more -->\n**身份证号的结构 15位**\n```\n地区：[1-6][1-9]\\d{4}\n年份只有后两位：\\d{2}\n月份：((0[1-9])|10|11|12)\n天数：(([0-2][1-9])|10|20|30|31)      闰年不能禁止29+\n三位顺序码： \\d{3}\n// 校验15位的身份证\nlet _IDRe15 =  /^([1-6][1-9]|50)\\d{4}\\d{2}((0[1-9])|10|11|12)(([0-2][1-9])|10|20|30|31)\\d{3}$/\n```\n**终极版：同时校验18位和15位的身份证**\n```javascript\nlet _IDRe18 = /^([1-6][1-9]|50)\\d{4}(18|19|20)\\d{2}((0[1-9])|10|11|12)(([0-2][1-9])|10|20|30|31)\\d{3}[0-9Xx]$/\nlet _IDre15 =  /^([1-6][1-9]|50)\\d{4}\\d{2}((0[1-9])|10|11|12)(([0-2][1-9])|10|20|30|31)\\d{3}$/\n// 校验身份证：\nif( _IDRe18.test( idVal ) || _IDre15.test( idVal )  ) {\n\tconsole.log(' 验证通过 ')\n} else {\n\tconsole.log(' 验证未通过 ')\n}\n```\n\n>1．号码的结构\n　　公民身份号码是特征组合码，由十七位数字本体码和一位校验码组成。排列顺序从左至右依次为：六位数字地址码，八位数字出生日期码，三位数字顺序码和一位数字校验码。\n2．地址码\n　\t表示编码对象常住户口所在县（县级市、旗、区）的行政区划代码，按GB/T2260的规定执行。\n3．出生日期码\n　　表示编码对象出生的年、月、日，按GB/T7408的规定执行，年、月、日代码之间不用分隔符。\n4．顺序码\n　　表示在同一地址码所标识的区域范围内，对同年、同月、同日出生的人编定的顺序号，顺序码的奇数分配给男性，偶数分配给女性。\n5．校验码\n　　根据前面十七位数字码，按照ISO 7064:1983.MOD 11-2校验码计算出来的检验码。\n\n>地址码\n\t\t1．华北地区：北京市|110000，天津市|120000，河北省|130000，山西省|140000，内蒙古自治区|150000\n\t\t2．东北地区： 辽宁省|210000，吉林省|220000，黑龙江省|230000\n\t\t华东地区： 上海市|310000，江苏省|320000，浙江省|330000，安徽省|340000，福建省|350000，江西省|360000，山东省|370000，台湾省(886)|710000\n\t\t3．华中地区： 河南省|410000，湖北省|420000，湖南省|430000\n\t\t4．华南地区：广东省|440000，广西壮族自治区|450000，海南省|460000，香港特别行政区（852)|810000，澳门特别行政区（853)|820000\n\t\t5．西南地区： 四川省|510000，贵州省|520000，云南省|530000，西藏自治区|540000，重庆市|500000\n\t\t6．西北地区： 陕西省|610000，甘肃省|620000，青海省|630000，宁夏回族自治区|640000，新疆维吾尔自治区|650000\n\n>中国大陆居民身份证号码中的地址码的数字编码规则为：\n\t\t第一、二位表示省（自治区、直辖市、特别行政区）。\n\t\t第三、四位表示市（地级市、自治州、地区、盟及直辖市所属区和县的汇总码）。其中，01-20，51-70表示地级市；21-50表示地区（自治州、盟）。\n\t\t第五、六位表示县（区、县级市、旗）。01-18表示地级市、自治州、地区、盟辖县级市；21-80表示县（旗）；81-99表示省直辖县级行政单位。\n\n>生日期码\n1．（身份证号码第七位到第十四位）表示编码对象出生的年、月、日，其中年份用四位数字表示，年、月、日之间不用分隔符。例如：1981年05月11日就用19810511表示。\n\n>顺序码\n1．（身份证号码第十五位到十七位）地址码所标识的区域范围内，对同年、月、日出生的人员编定的顺序号。其中第十七位奇数分给男性，偶数分给女性。\n\n>校验码\n1．作为尾号的校验码，是由号码编制单位按统一的公式计算出来的，如果某人的尾号是0-9，都不会出现X，但如果尾号是10，那么就得用X来代替，因为如果用10做尾号，那么此人的身份证就变成了19位，而19位的号码违反了国家标准，并且中国的计算机应用系统也不承认19位的身份证号码。Ⅹ是罗马数字的10，用X来代替10，可以保证公民的身份证符合国家标准。\n\n\n\n\n"},{"title":"Clipboard.js 实现点击复制","url":"/2020/06/02/Clipboard-js-实现点击复制/","content":"在开发过程中难免会遇到点击分享的需求，这里有两种实现方式：\n**第一种：** 通过原生js 的方法用（**存在兼容性**）：\n\n**document.execCommand(** aCommandName, aShowDefaultUI, aValueArgument**)**\n参数说明：\n\t\t**aCommandName**\n\t\t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令的名称：常用的为\"copy\",\"cut\"等；\n\n注：\"copy\"  拷贝当前选中内容到剪贴板\n<!-- more -->\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \"cut\"&nbsp;&nbsp;  剪贴当前选中的文字并复制到剪贴板\n\t\t**aShowDefaultUI**\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是否展示用户界面，一般为 false；\n\n&nbsp;**aValueArgument**\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认为null;\n\n**返回值:Boolean** 如果还是false 则表示还不能支持；\n\nhtml ：\n```html\n<input type=\"text\" id=\"copyVal\" readonly value=\"被复制内容\" />\n<button class=\"copyBtn\" >点击复制</button>\n```\njavascript：\n\n```javascript\nvar copyBtn = document.getElementsByClassName('copyBtn')[0];\n\n\tcopyBtn.onclick = function(){\n\t    var copyVal = document.getElementById(\"copyVal\");\n\t        copyVal.select();\n\n\t    try{\n\t        if(document.execCommand('copy', false, null)){\n\t            //success info\n\t            console.log(\"doSomething...\");\n\t        } else{\n\t            //fail info\n\t            console.log(\"doSomething...\");\n\t        }\n\t    } catch(err){\n\t        //fail info\n\t        console.log(\"doSomething...\");\n\t    }\n\t}\n```\n具体兼容如下-pc 端浏览器：\n![tt2EEd.png](https://s1.ax1x.com/2020/06/02/tt2EEd.png)\n![tt2kHH.png](https://s1.ax1x.com/2020/06/02/tt2kHH.png)\n移动端浏览器-ios:\n\t目前是不支持所有浏览器，包括微信浏览器；\n\n**第二种** 使用clipboard.js 实现(**个人推荐**)：\n 它是一个不需要Flash,就能实现文本复制或者剪切到剪切板的轻量级插件；\n 其中需要两个参数是\n > data-clipboard-action 是操作类型值为复制（copy ），剪切（cut） 默认为copy 可以选择不加该属性\n > data-clipboard-target 是要复制或者剪切的对象的id值  必选选项\n\n 具体实例：\n 可以使用[cdn](https://github.com/zenorocha/clipboard.js/wiki/CDN-Providers) 或者[直接下载](https://github.com/zenorocha/clipboard.js/archive/master.zip) 设置好引用路径\n```\n<script type=\"text/javascript\" src=\"./dist/clipboard.min.js\"></script>\n```\nhtml\n\n```html\n<input type=\"text\" id=\"copyVal\" readonly value=\"被复制内容\" />\n\n<button class=\"copyBtn\"   data-clipboard-target=\"#copyVal\">点击复制</button>\n```\njavascript\n\n```javascript\n\t\t//实例化 ClipboardJS对象;\n        var copyBtn = new ClipboardJS('.copyBtn');\n\n        copyBtn.on(\"success\",function(e){\n            // 复制成功\n            alert(e.text);\n            e.clearSelection();\n        });\n        copyBtn.on(\"error\",function(e){\n            //复制失败；\n            console.log( e.action )\n        });\n```\n#### 这里的ClipboardJS在实例化时， 如果报错：`clipboard is not defined`\n\n#### 解决办法就是如下：\n```javascript\nnew ClipboardJS(obj)\n```\n#### 原因就是 Clipboard.JS版本是2.0及以上版本\n\n\n\n"},{"title":"vue rander函数 on事件触发失败","url":"/2020/06/02/vue-rander函数-on事件触发失败/","content":"在编写组件时 使用rander函数编写组件 发现事件没有被触发后来发现写的方式不对\n错误的使用\n````javascript\n// js\nrender(h){\n\treturn h(\n\t'div',\n\t{\n\t  'class': {\n        foo: true,\n        bar: false\n      },\n      style: {\n        // color: 'red',\n        fontSize: '14px',\n        width: '100px',\n        // height: '20px',\n        backgroundColor: '#bf0000'\n      },\n      attrs: {\n        id: 'foo'\n      },\n      // 需要手动匹配 keyCode。\n      on: {\n        click: (data)=>{\n       \t\tthis.$emit(\"click\",data)\n       \t },\n        visiableChange:value => {\n        \t //这里有一个事件名称不是单单词 但是我们on监听时候发现就触发不了emit\n            this.$emit('visible-change', value);\n        }\n      },\n    },\n    [\n      '一些内容',\n      createElement('h1', '一条文字')\n    ]\n  )\n}\n\n````\n<!-- more -->\n正确使用\n```javascript\nrender(h){\n\treturn h(\n\t'div',\n\t{\n\t  'class': {\n        foo: true,\n        bar: false\n      },\n      style: {\n        // color: 'red',\n        fontSize: '14px',\n        width: '100px',\n        // height: '20px',\n        backgroundColor: '#bf0000'\n      },\n      attrs: {\n        id: 'foo'\n      },\n      // 需要手动匹配 keyCode。\n      on: {\n        click: (data)=>{\n       \t\tthis.$emit(\"click\",data)\n       \t },\n        \"visiable-change\":value => {\n        \t //这里的解决办法就是使用引号包裹一下，就解决非单单词事件名称\n            this.$emit('visible-change', value);\n        }\n      },\n    },\n    [\n      '一些内容',\n      createElement('h1', '一条文字')\n    ]\n  )\n}\n```\n**问题：**\n\t**render编写组件 非单单词无法触发emit事件**\n\n**解决办法：**\n\n\t将非单单词修改为原生事件名称层 然后用引号包裹一下\n"},{"title":"vue开发 cross-env跨平台设置环境变量","url":"/2020/06/02/vue开发-cross-env跨平台设置环境变量/","content":"# vue开发 cross-env跨平台设置环境变量\nvue开发过程成中使用环境变量 以便在不同的环境里面查看不同的数据。\ncross-env可以很方便帮我们解决\n关于介绍 [cross-env](https://www.npmjs.com/package/cross-env)\n\n首先安装 cross-env\n```\nnpm install cross-env --save-dev\n```\n<!-- more -->\n使用\n在package.json 里面配置环境变量名称\n```javascript\n// config/proxyDev.js 代理地址一\nconst proxyDev = {\n  '/api': {\n    target: 'http://xxxxxxxxxxxx', // 代理的接口地址\n    secure: false // 是否验证SSL\n  }\n};\nmodule.exports = proxyDev;\n```\n```javascript\n// config/proxyTestCenter.js 代理地址二\nconst proxyTestCenter= {\n  '/api': {\n    target: 'http://xxxxxxxxxxxxx', // 代理的接口地址\n    secure: false // 是否验证SSL\n  }\n};\nmodule.exports = proxyTestCenter;\n```\n```javascript\n// config/index.js 新增下面代码\nconst proxyDev= require('./proxyDev'); // 新建文件\nconst proxyTestCenter= require('./proxyTestCenter'); // 新建文件\n\nlet proxyPath;\nswitch (process.env.proxyPath) { // 根据命令来切换环境变量\n  case 'dev': proxyPath = proxyDev; break;\n  case 'tc': proxyPath = proxyTestCenter; break;\n}\n```\n修改**config/index.js** 文件\n```javascript\n// 修改config/index.js 文件\n\nmodule.exports = {\n\tdev: {\n\t\t...\n\t\tproxyTable: proxyPath, // 将 proxyTable得知替换为上面定义的proxyPath 以便使用命令更换环境变量\n\t\t...\n\t}\n\n\t...\n}\n```\n在package.json中配置命令 在package.json中修改如下代码：\n```javascript\n// package.json 中修改scripts 的dev和rc; 配置方式模板 cross-env key=value 注：这里的key是proxyTable value是dev和tc;\n   ...\n   \"scripts\": {\n    \t\"dev\": \"cross-env proxyTable=dev webpack-dev-server --inline --progress --config build/webpack.dev.conf.js\",\n    \t\"tc\": \"cross-env proxyTable=tc webpack-dev-server --inline --progress --config build/webpack.dev.conf.js\",\n\t\t...\n  \t},\n  \t...\n```\n最后在使用不同的编译命令就可以来改变环境变量\n```\nnpm run dev  //执行的是 dev环境变量\n\nnpm run tc  //执行的是 tc环境变量\n```\n参考博文/文档：[^1]\n [http-proxy-middleware 代理]: https://www.npmjs.com/package/http-proxy-middleware\n [cross-env 跨平台设置环境变量]: https://www.npmjs.com/package/cross-env\n"},{"title":"ios上input的focus()、autofocus无效处理","url":"/2020/06/02/ios上input的focus-、autofocus无效处理/","content":"## 出现focus无效原因：\n> **ios的UIWebView 默认的KeyboardDisplayRequiresUserAction为false，设置为true就行，WKWebView 不支持这个属性，如果要从原生入手解决，请参考https://stackoverflow.com/questions/32407185/wkwebview-cant-open-keyboard-for-input-field**\n## 解决思路：\n> **从无效原因可以看出，是键盘需要用户触发才能弹出，这导致了autofocus或者element.focus()无效，所以，在键盘弹出的情况下再去focus，或者跳转到带有autofocus的页面也就可以正常focus了**\n<!-- more -->\n## 解决方法：\n> **通常的场景是，我们点击页面某个元素 => 逻辑交互 => 希望focus元素、或者跳转到有aotufocus的页面。再这里有个大前提，就是要有点击页面行为。**\n\n## 划重点\n>**只要是点击事件的回调就具备focus到input的能力，所以无论是点击生成input再focus到这个input、还是跳转到autofocus的页面，先利用点击focus到一个占位input调起键盘，在键盘存在的情况下调用element.focus()或者跳转到有autofocus的页面就都可以正常focus了。**\n```javascript\n.clip{\n  position: absolute;\n  clip: rect(0 0 0 0);\n}\n\n<input ref=\"tempFocus\" class=\"clip\">\n\n<div @click=\"gotoCommentClick\">快来留言吧！</div>\n\ngotoCommentClick() {\n  this.afterLogin().then(_ => {\n    this.$refs.tempFocus.focus();\n    this.$router.push(this.$route.path + '/comment');\n  })\n},\nmounted() {\n    this.$refs.editor.focus();\n  }\n```\n\n### 注意事项 就是调起的键盘如果收回还是会出现focus(),autofocus无效；\n参考文章  [ios上input的focus()、autofocus无效处理方法](https://www.jianshu.com/p/ea0b447c781e)\n"},{"title":"h5页面在安卓手机浏览器上不能上下移动的问题","url":"/2020/06/02/h5页面在安卓手机浏览器上不能上下移动的问题/","content":"1、**当在css中加入下面样式，会导致页面无法正常上下滑动**\n```css\n// css 文件\n{ touch-action: none; }\n```\n**这行代码后，会导致页面无法正常上下滑动，**\n<!-- more -->\n## 解决办法：修改为默认值```{ touch-action: auto; }```或者删除改行样式\n原因：\nCSS属性 touch-action 值说明：\nauto\n\t当触控事件发生在元素上时，由浏览器来决定进行哪些操作，比如对viewport进行平滑、缩放等。\nnone\n\t**当触控事件发生在元素上时，不进行任何操作。**\npan-x\n\t启用单指水平平移手势。可以与 pan-y 、pan-up、pan-down 和／或 pinch-zoom 组合使用。\npan-y\n\t启用单指垂直平移手势。可以与 pan-x 、pan-left 、pan-right 和／或 pinch-zoom 组合使用。\nmanipulation\n\t浏览器只允许进行滚动和持续缩放操作。任何其它被auto值支持的行为不被支持。启用平移和缩小缩放手势，但禁用其他非标准手势，例如双击以进行缩放。 禁用双击可缩放功能可减少浏览器在用户点击屏幕时延迟生成点击事件的需要。 这是“pan-x pan-y pinch-zoom”（为了兼容性本身仍然有效）的别名。\npan-left, pan-right,pan-up,pan-down\n\t启用以指定方向滚动开始的单指手势。 一旦滚动开始，方向可能仍然相反。 请注意，滚动“向上”（pan-up）意味着用户正在将其手指向下拖动到屏幕表面上，同样 pan-left 表示用户将其手指向右拖动。 多个方向可以组合，除非有更简单的表示（例如，“pan-left pan-right”无效，因为“pan-x”更简单，而“pan-left pan-down”有效）。\npinch-zoom\n启用多手指平移和缩放页面。 这可以与任何平移值组合。\n[参考地址:关于touch-action的用法\n](https://developer.mozilla.org/zh-CN/docs/Web/CSS/touch-action)\n\n2.是否在css中加入了overflow：hidden；\n超出隐藏也会导致页面无法滑动；\n```css\n\t// css 文件\n\t{ overflow：hidden；}\n````\n3、js方面的问题，主要是有在touchstart、touchmove或touchend等事件中的阻止默认事件的原因\n```js\n// js文件\ne.preventDefault();   //会阻止默认行为\n```\n\n最后滑动动作优化\n```css\n上下拉动滚动条时卡顿、慢\n\n body {\n    -webkit-overflow-scrolling: touch;\n    overflow-scrolling: touch;\n}\n```\n"},{"title":"npm install -S | --save | -D | --save-dev | -g 说明","url":"/2020/06/02/npm-install-S-save-D-save-dev-g-说明/","content":"npm 安装包命令\n#### 1、局部安装\n```\nnpm install <package_name>\n```\n说明 安装到当前项目\n>npm 5x 以后 这个命令等同于npm install --save <package_name> 同时也是会同样写入到依赖 dependencies\n\n#### 2、 全局安装 -g\n<!-- more -->\n```\nnpm install -g <package_name>\n```\n安装到全局并不会体现到package.json 里面\n\n#### 3、安装到生产依赖 --save\n```\nnpm install  <package_name>  --save | -S\n```\n安装到当前项目，并将包信息写入到dependencies\n\n#### 4、安装到开发依赖 --save-dev\n```\nnpm install  <package_name>  --save-dev | -D\n```\n安装到当前项目 并写入到devDependencies\n\n##### devDependencies与dependencies 的区别:\n\n>devDependencies 是本地开发时用的依赖项\n>dependencies 是生产环境的依赖项\n\n##### 安装依赖包\n```\nnpm install\n```\n会将package.json 里面的devDependencies和dependencies下的所有包都会下载到项目的node_modules文件夹下(没有的改文件夹会新建一个)\n##### 只安装生产依赖\n```\nnpm install --production\n```\n\n"},{"title":"webkit-overflow-scrolling:touch; ios橡皮筋效果卡屏，滚动穿透 --已解决","url":"/2020/06/02/webkit-overflow-scrolling-touch-ios橡皮筋效果卡屏，滚动穿透-已解决/","content":"#### -webkit-overflow-scrolling 属性\n[MDN中概述](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) 入下\n>-webkit-overflow-scrolling 属性控制元素在移动设备上是否使用滚动回弹效果.\n\n##### 值选项\n> 1、auto\n>   使用普通滚动, 当手指从触摸屏上移开，滚动会立即停止\n>   2、touch\n>   使用具有回弹效果的滚动, 当手指从触摸屏上移开，内容会继续保持一段时间的滚动效果。继续滚动的速度和持续的时间和滚动手势的强烈程度成正比。同时也会创建一个新的堆栈上下文。\n<!-- more -->\n#### 问题 BUG\n##### 1、使用了-webkit-overflow-scrolling:touch之后，页面偶尔会卡住不动。\n   **复现场景**：发现页面在滚动期间是不会出现卡住的问题，但是在滚动条到顶部或者底部的时候会出现这个问题\n   **分析问题**：如果在到达顶部/底部的时候不让它到达顶部/底部,是不是可以规避这个问题\n   **解决办法**: 在滑动的时候为滑动区域添加 ```scroll事件```监听滚动条是否到了底部/顶部 如果到了顶部/底部那么让```scrollTop```[^1]相应的减少 1；\n   代码如下：\n```javascript\n// js 文件\n\n// 获取滚动区域\nlet el = document.getElementById('scrollSectionArea')\n// 获取滚动内容的高度 如果是在是vue 使用动态的获取高度请将获取元素替换为 ref 来获取,不然是获取不到高度的 在监听函数内部注意this指向\nlet scrollHeight =  document.getElementById('scrollSection').scrollHeight;\n\nel.addEventListener('scroll', function() {\n// 如果滚动条到顶部/底部则scrollTop值相应的减 1\n\tif (el.scrollTop <= 1) {\n\t  el.scrollTop = 1;\n\t}\n\tif ((el.scrollTop + el.offsetHeight) >= (scrollHeight - 1)) {\n\t  el.scrollTop = scrollHeight - el.offsetHeight - 1;\n\t}\n});\n```\n2、使用了-webkit-overflow-scrolling:touch之后，弹窗会引发底部滑动（滚动穿透）。\n  **复现场景**：弹窗带有滚动内容 滑动到底部或者顶部会触发底层的滚动；\n   **分析问题**：滚动事件穿透，\n   **解决办法**: 弹窗显示的时候固定底部滚动并记录底层scrollTop值，并将底部内容设置为position: fixed;\n  height: 100%; 来达到固定底层的目的，然后就可以规避滚动穿透；\n  代码如下：\n ```css\n // css\n /* 解决点击穿透滑动失效 */\n.mask_show {\n  position: fixed;\n  height: 100%;\n}\n  ```\n```javascript\n// js部分\ndata:{\n\treturn {\n\t...\n\t\teventScrollTop: 0\n\t...\n\t}\n}\n\nmethods:{\n\t// 弹窗显示的时候调用 记录底部滚动条位置\n\tsetScrollTopValue() {\n\t\tthis.eventScrollTop = document.scrollingElement.scrollTop ||\n\t\t                document.documentElement.scrollTop ||\n\t\t                document.body.scrollTop;\n\t\tdocument.body.classList.add('mask_show ');\n\t\tdocument.body.style.top = -this.eventScrollTop + 'px';\n\t},\n\t// 弹窗关闭的时候调用 回归到原来滚动条位置\n\tuseScrollTopValue() {\n\t    document.body.classList.remove('mask_show');\n\t    document.scrollingElement.scrollTop = document.documentElement.scrollTop = document.body.scrollTop = this.eventScrollTop;\n\t}\n}\n```\n\n[^1]: 底部 scrollTop = scrollHeight- offsetHeight\n**offsetHeight**：包括元素的边框、内边距和元素的水平滚动条（如果存在且渲染的话），不包含:before或:after等伪类元素的高度。\n**scrollHeight**：值与元素视图填充所有内容所需要的最小值clientHeight相同。包括元素的padding，但不包括元素的border和margin。scrollHeight也包括 ::before 和 ::after这样的伪元素。\n\n参考文档：[滚动穿透问题的解决方案](https://mp.weixin.qq.com/s?__biz=MzUyNDYxNDAyMg==&mid=2247484280&idx=1&sn=63ae69e55f3590c42f52c208db3bc3be&chksm=fa2be391cd5c6a877a6ab37d17067a2a1998ffdc9af42aa4a1cda7f93a6b7f457529eb64896b&mpshare=1&scene=1&srcid=&key=8df06d6b6fc234cf15109e8931ffa1e60dc6de4f8a5b317840422a6bdb0ca8558f888c8bd545b30566e4e1f1b7b339e17875e54d16411a596fb5ef1b02a50359b8550a248aa25aab345754dec0a0f290&ascene=1&uin=MTMyMzkwNzQ0MQ%3D%3D&devicetype=Windows+10&version=62060739&lang=zh_CN&pass_ticket=sGx9Uuwxeper%2B1H5fZA88N2x1ErrdSdkX4lVKdIZrxZeWVcwNUXvzfdZ50Qz0ia6)\n"},{"title":"CSS3手工彩虹","url":"/2020/06/02/CSS3手工彩虹/","content":"[![ttrrEq.png](https://s1.ax1x.com/2020/06/02/ttrrEq.png)](https://imgchr.com/i/ttrrEq)\n### html\n```html\n    <div class=\"caihong\"></div>\n```\n<!-- more -->\n### css\n```css\n  .caihong {\n    width: 200px;\n    height: 200px;\n    border-radius: 50%;\n    box-shadow:\n      0 0 0 5px inset red,\n      0 0 0 10px inset orange,\n      0 0 0 15px inset yellow,\n      0 0 0 20px inset lime,\n      0 0 0 25px inset aqua,\n      0 0 0 30px inset blue,\n      0 0 0 35px inset magenta;\n      clip-path: polygon(0 0, 100% 0, 100% 50%, 0 50%)\n\n  }\n```\n参考地址：[clip-path属性详情https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path#fill-rule](https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path#fill-rule)\n"},{"title":"常用 git命令大全","url":"/2020/06/02/常用-git命令大全/","content":"Git图形化界面使用容易，但是命令就不太会了, 所以学习下Git命令的用法...\n一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。\n[![ttJdGn.jpg](https://s1.ax1x.com/2020/06/02/ttJdGn.jpg)](https://imgchr.com/i/ttJdGn)\n<!-- more -->\n![ttJw2q.jpg](https://s1.ax1x.com/2020/06/02/ttJw2q.jpg)\n\n ---\n #### fetch vs pull\ngit fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。\n而git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。\n\n---\n\n用 Git 命令清单。几个专用名词的译名如下。\n```git\nWorkspace：工作区\nIndex / Stage：暂存区\nRepository：仓库区（或本地仓库）\nRemote：远程仓库\n```\n### 一、新建代码库\n```git\n# 在当前目录新建一个Git代码库\n$ git init\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n```\n### 二、配置\nGit的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n```git\n# 显示当前的Git配置\n$ git config --list\n# 编辑Git配置文件\n$ git config -e [--global]\n# 设置提交代码时的用户信息\n$ git config [--global] user.name \"[name]\"\n$ git config [--global] user.email \"[email address]”\n\ngit 修改当前的project的用户名的命令为：\n> git config user.name 你的目标用户名;\ngit修改当前的project提交邮箱的命令为：\n> git config user.email 你的目标邮箱名;\n如果你要修改当前全局的用户名和邮箱时，需要在上面的两条命令中添加一个参数，–global，代表的是全局。\n命令分别为：\n> git config  --global user.name 你的目标用户名；\n> git config  --global user.email 你的目标邮箱名;\n```\n### 三、增加/删除文件\n```git\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n# 添加当前目录的所有文件到暂存区\n$ git add .\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n```\n### 四、代码提交\n```git\n# 提交暂存区到仓库区\n$ git commit -m [message]\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n# 提交时显示所有diff信息\n$ git commit -v\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n```\n### 五、分支\n```git\n# 列出所有本地分支\n$ git branch\n# 列出所有远程分支\n$ git branch -r\n# 列出所有本地分支和远程分支\n$ git branch -a\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\ngit checkout -b appoint_box（别名） origin/feature/20181128_1491627_appoint_box_1（分支名）\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n# 切换到上一个分支\n$ git checkout -\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n# 合并指定分支到当前分支\n$ git merge [branch]\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n# 删除分支\n$ git branch -d [branch-name]\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n```\n### 六、标签\n```git\n# 列出所有tag\n$ git tag\n# 新建一个tag在当前commit\n$ git tag [tag]\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n# 删除本地tag\n$ git tag -d [tag]\n# 删除远程tag\n$ git push origin :refs/tags/[tagName]\n# 查看tag信息\n$ git show [tag]\n# 提交指定tag\n$ git push [remote] [tag]\n# 提交所有tag\n$ git push [remote] --tags\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n```\n### 七、查看信息\n```git\n# 显示有变更的文件\n$ git status\n# 显示当前分支的版本历史\n$ git log\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n# 显示暂存区和工作区的代码差异\n$ git diff\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n# 显示今天你写了多少行代码\n$ git diff --shortstat \"@{0 day ago}\"\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n# 显示当前分支的最近几次提交\n$ git reflog\n可以得到cimmit id\n# 从本地master拉取代码更新当前分支：branch 一般为master\n$ git rebase [branch]\n```\n### 八、远程同步\n```git\n$ git remote update  --更新远程仓储\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n# 显示所有远程仓库\n$ git remote -v\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n```\n### 九、撤销\n```git\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n```\n### 十、其他\n```git\n# 生成一个可供发布的压缩包\n$ git archive\n```\n上传本地项目到远程仓库\n1、（先进入项目文件夹）通过命令 git init 把这个目录变成git可以管理的仓库\n```git\ngit init\n```\n2、把文件添加到版本库中，使用命令 git add .添加到暂存区里面去，不要忘记后面的小数点“.”，意为添加文件夹下的所有文件\n```git\ngit add .\n```\n3、用命令 git commit告诉Git，把文件提交到仓库。引号内为提交说明\n```git\ngit commit -m 'first commit'\n```\n4、关联到远程库\n```git\ngit remote add origin 你的远程库地址\n```\n如：\n```git\ngit remote add origin https://github.com/githubusername/demo.git\n```\n5、获取远程库与本地同步合并（如果远程库不为空必须做这一步，否则后面的提交会失败）\n```git\ngit pull --rebase origin master\n```\n6、把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。执行此命令后会要求输入用户名、密码，验证通过后即开始上传。\n```git\ngit push -u origin master\n```\n7、状态查询命令\n```git\ngit status\n```\n"},{"title":"element-ui table列合并--支持多个列 开箱即用","url":"/2020/06/02/element-ui-table列合并-支持多个列-开箱即用/","content":"项目中使用table组件的时候，存在合并列或者合并行看element-ui table组件的文档\n由于数据是动态获取，所以存在合并不方便的场景\n所以换个思路来实现合并\n具体代码：\n<!-- more -->\n```html\n      <el-table\n        :data=\"tableData\"\n        :span-method=\"arraySpanMethod\"\n        border\n        style=\"width: 100%; margin-top: 20px\">\n        <el-table-column\n          prop=\"id\"\n          label=\"ID\"\n          width=\"180\">\n        </el-table-column>\n        <el-table-column\n          prop=\"name\"\n          label=\"姓名\">\n        </el-table-column>\n        <el-table-column\n          prop=\"amount1\"\n          label=\"数值 1（元）\">\n        </el-table-column>\n        <el-table-column\n          prop=\"amount2\"\n          label=\"数值 2（元）\">\n        </el-table-column>\n        <el-table-column\n          prop=\"amount3\"\n          label=\"数值 3（元）\">\n        </el-table-column>\n      </el-table>\n```\n```js\nexport default {\n\tdata(){\n\t\treturn {\n\t\t  // 模拟后台返回数据\n\t\t  tableData: [{\n\t          id: '12987122',\n\t          name: '王小虎',\n\t          amount1: '234',\n\t          amount2: '3.2',\n\t          amount3: 10\n\t        }, {\n\t          id: '12987123',\n\t          name: '王小虎',\n\t          amount1: '165',\n\t          amount2: '4.43',\n\t          amount3: 12\n\t        }, {\n\t          id: '12987124',\n\t          name: '王小虎',\n\t          amount1: '324',\n\t          amount2: '1.9',\n\t          amount3: 9\n\t        }, {\n\t          id: '12987125',\n\t          name: '王小虎',\n\t          amount1: '621',\n\t          amount2: '2.2',\n\t          amount3: 17\n\t        }, {\n\t          id: '12987126',\n\t          name: '王小虎',\n\t          amount1: '539',\n\t          amount2: '4.1',\n\t          amount3: 15\n\t        }, {\n\t          id: '12987126',\n\t          name: '王小虎3',\n\t          amount1: '539',\n\t          amount2: '4.1',\n\t          amount3: 15\n\t        }, {\n\t          id: '12987126',\n\t          name: '王小虎2',\n\t          amount1: '539',\n\t          amount2: '4.1',\n\t          amount3: 15\n\t        }, {\n\t          id: '12987126',\n\t          name: '王小虎2',\n\t          amount1: '539',\n\t          amount2: '4.1',\n\t          amount3: 15\n\t        }],\n        needMergeArr: ['name', 'id'], // 有合并项的列\n     \trowMergeArrs: {}, // 包含需要一个或多个合并项信息的对象\n\t\t};\n\t},\n\tmethods:{\n\t\t    /**\n\t\t     * @description 实现合并行或列\n\t\t     * @param row:Object 需要合并的列name 如:'name' 'id'\n\t\t     * @param column:Object 当前行的行数，由合并函数传入\n\t\t     * @param rowIndex:Number 当前列的数据，由合并函数传入\n\t\t     * @param columnIndex:Number 当前列的数据，由合并函数传入\n\t\t     *\n\t\t     * @return 函数可以返回一个包含两个元素的数组，第一个元素代表rowspan，第二个元素代表colspan。 也可以返回一个键名为rowspan和colspan的对象\n\t\t     * 参考地址：https://element.eleme.cn/#/zh-CN/component/table#table-biao-ge\n\t\t    */\n\t\t    arraySpanMethod({ row, column, rowIndex, columnIndex }) {\n\t\t        // 没办法循环判断具体是那一列 所以就只好写了多个if\n\t\t        if (column.property === 'name') return this.mergeAction('name', rowIndex, column);\n\t\t        if (column.property === 'id') return this.mergeAction('id', rowIndex, column);\n\t\t    },\n\t\t    /**\n\t\t     * @description 根据数组来确定单元格是否需要合并\n\t\t     * @param val:String 需要合并的列name 如:'name' 'id'\n\t\t     * @param rowIndex:Number 当前行的行数，由合并函数传入\n\t\t     * @param colData:Object 当前列的数据，由合并函数传入\n\t\t     *\n\t\t     * @return 返回值为一个数组表示该单元格是否需要合并; 说明: [0,0]表示改行被合并了 [n+,1]n为1时表示该单元格不动,n大于1时表示合并了N-1个单元格\n\t\t    */\n\t\t    mergeAction(val, rowIndex, colData) {\n\t\t        let _row = this.rowMergeArrs[val].rowArr[rowIndex];\n\t\t        let _col = _row > 0 ? 1 : 0;\n\t\t        return [_row, _col];\n\t\t    },\n\t\t    /**\n\t\t     * @description 根据数组将指定对象转化为相应的数组\n\t\t     * @param arr:Array[String] 必填 必须是字符串形式的数组\n\t\t     * @param data:Array 必填 需要转化的对象\n\t\t     *\n\t\t     * @return 返回一个对象\n\t\t     * 例：rowMerge(['name','value'], [{value:'1', name:'小明'}, {value:'2', name:'小明'}, {value:'3', name:'小明'}, {value:'1', name:'小明'}, {value:'1', name:'小明'}])\n\t\t     * 返回值: {\n\t\t     *          name:{\n\t\t     *            rowArr: [5, 0, 0, 0, 0]\n\t\t     *            rowMergeNum: 0,\n\t\t     *          },\n\t\t     *          value: {\n\t\t     *            rowArr: [1, 1, 1, 2, 0],\n\t\t     *            rowMergeNum: 3\n\t\t     *          }\n\t\t     *        }\n\t\t    */\n\t\t    rowMergeHandle(arr, data) {\n\t\t      if (!Array.isArray(arr) && !arr.length) return false;\n\t\t      if (!Array.isArray(data) && !data.length) return false;\n\t\t      let needMerge = {};\n\t\t      arr.forEach(i => {\n\t\t        needMerge[i] = {\n\t\t          rowArr: [],\n\t\t          rowMergeNum: 0\n\t\t        };\n\t\t        data.forEach((item, index) => {\n\t\t          if (index === 0) {\n\t\t            needMerge[i].rowArr.push(1);\n\t\t            needMerge[i].rowMergeNum = 0;\n\t\t          } else {\n\t\t            if (item[i] === data[index - 1][i]) {\n\t\t              needMerge[i].rowArr[needMerge[i].rowMergeNum] += 1;\n\t\t              needMerge[i].rowArr.push(0);\n\t\t            } else {\n\t\t              needMerge[i].rowArr.push(1);\n\t\t              needMerge[i].rowMergeNum = index;\n\t\t            }\n\t\t          }\n\t\t        });\n\t\t      });\n\t\t      return needMerge;\n\t\t    }\n\t\t  }\n\t},\n\tmounted(){\n\t\tthis.rowMergeArrs = this.rowMergeHandle(this.needMergeArr, this.tableData); // 处理数据\n\t}\n}\n```\n效果如下：\n[![ttGzE4.png](https://s1.ax1x.com/2020/06/02/ttGzE4.png)](https://imgchr.com/i/ttGzE4)\n\n[参考地址 - elementUI表格合并单元格](https://www.cnblogs.com/yuwenjing0727/p/10110721.html)\n"},{"title":"解决：Uncaught ReferenceError: regeneratorRuntime is not defined","url":"/2020/06/02/解决：Uncaught-ReferenceError-regeneratorRuntime-is-not-defined/","content":"在使用 vuex actions 里的 异步函数 （async）时，出现**regeneratorRuntime is not defined** 错误\n\n问题：\n\t**使用 ES7 的 async/await 时报错。**\n\n**原因：regeneratorRuntime在浏览器上无法识别，需要安装一个\nbabel-plugin-transform-runtime插件**\n<!-- more -->\n安装插件\n```javascript\nnpm i --save-dev babel-plugin-transform-runtime\n```\n\n在 **.babelrc** 文件中添加\n```javasript\n\"plugins\": [\n\t[\n\t  \"transform-runtime\",\n\t  {\n\t    \"helpers\": false,\n\t    \"polyfill\": false,\n\t    \"regenerator\": true,\n\t    \"moduleName\": \"babel-runtime\"\n\t  }\n\t]\n]\n```\n"},{"title":"html input='file' 浏览时只显示指定文件类型 如xls、xlsx、csv、","url":"/2020/06/02/html-input-file-浏览时只显示指定文件类型-如xls、xlsx、csv、/","content":"html:\n```html\n<input id=\"fileSelect\" type=\"file\" accept=\".csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel\" />\n```\nValid Accept Types:\n对于 CSV 文件 (.csv), 使用:\n```html\n<input type=\"file\" accept=\".csv\" />\n```\n对于Excel 2003-2007 (.xls)文件, 使用:\n```html\n<input type=\"file\" accept=\"application/vnd.ms-excel\" />\n```\n 对于Excel 2010 (.xlsx)文件, 使用:\n```html\n<input type=\"file\" accept=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\" />\n```\n对于文本 (.txt)文件, 使用:\n```html\n<input type=\"file\" accept=\"text/plain\" />\n```\n<!-- more -->\n对于图片(.png/.jpg/etc)文件, 使用:\n```html\n<input type=\"file\" accept=\"image/*\" />\n```\n对于 HTML (.htm,.html)文件, 使用:\n```html\n<input type=\"file\" accept=\"text/html\" />\n```\n对于视频Video (.avi, .mpg, .mpeg, .mp4)文件, 使用:\n```html\n<input type=\"file\" accept=\"video/*\" />\n```\n对于音频Audio (.mp3, .wav, etc)文件, 使用:\n```html\n<input type=\"file\" accept=\"audio/*\" />\n```\n对于 PDF 文件, 使用:\n```html\n<input type=\"file\" accept=\".pdf\" />\n```\n\n\n"},{"title":"JS 正则匹配整数和小数","url":"/2020/06/02/JS-正则匹配整数和小数/","content":"正则匹配正整数和小数\n```javascript\nlet _check = /^([1-9][\\d]{0,6}|0)(\\.[\\d]{1,2})?$/; //限制小数点前后位数\nlet _check1 = /^([1-9][\\d]*|0)(\\.[\\d]+)?$/; //不限制小数点前后位数\n_check.test('0.10') // true\n_check.test('000.10') // false\n_check.test('0') // true\n_check.test('9') // true\n_check.test('9.9') // true\n_check.test('9.90') // true\n_check.test('9.900') // false\n_check.test('90')  // true\n_check.test('090')  // false\n_check.test('9..90')  // false\n_check.test('9.9.0') // false\n_check.test('009') // false\n_check.test('0009.90') //false\n_check.test('9000000')  // false\n```\n<!-- more -->\n"},{"title":"二进制数据转化为excel","url":"/2020/06/02/二进制数据转化为excel/","content":"原理就是通过a标签的href属性将二进制表格数据转化为表格，再通过download属性将文件下载到本地；\n需要注意的是接口请求的数据类型要设置为 **blob** 类型 [具体参考 axios https://www.npmjs.com/package/axios](https://www.npmjs.com/package/axios)\n```javascript\n  responseType: 'blob'\n```\n<!-- more -->\n具体的代码\n```javascript\n   let url = window.URL.createObjectURL(res.data);\n   let link = document.createElement('a');\n   link.style.display = 'none';\n   link.href = url;\n   link.setAttribute('download', filename); // filename 自定义下载的表格名称及后缀名；\n   document.documentElement.appendChild(link);\n   link.click();\n   document.documentElement.removeChild(link);\n```\n完整的例子：\n\n```javascript\n\t // 首先要引入axios\n\t  import axios from 'axios';\n\t// 组件内部新增方法\n      downloadExl(filename) {\n        axios({\n            method: 'get',\n            url: '/api/export',\n            params: Object, // Object 导出接口所需要的参数对象\n            responseType: 'blob'\n          }).then(res => {\n            let url = window.URL.createObjectURL(res.data);\n            let link = document.createElement('a');\n            link.style.display = 'none';\n            link.href = url;\n            link.setAttribute('download', filename);\n            document.documentElement.appendChild(link);\n            link.click();\n            document.documentElement.removeChild(link);\n          }).catch(e => {\n          \tconsole.log('导出失败')\n          }).finally(() => {\n          \tconsole.log('不管导出成功/失败')\n          });\n      },\n```\n"},{"title":"element-ui 日期组件最大日期和最小日期限制","url":"/2020/06/02/element-ui-日期组件最大日期和最小日期限制/","content":"element-ui 日期组件最大日期和最小日期\n```html\n<el-date-picker\n\tv-model=\"transactionDate\"\n\ttype=\"daterange\"\n\trange-separator=\"至\"\n\tstart-placeholder=\"开始日期\"\n\tend-placeholder=\"结束日期\"\n\tplaceholder=\"选择日期\"\n\tvalue-format=\"yyyy-MM-dd HH:mm:ss\"\n\t:default-time=\"['00:00:00','23:59:59']\"\n\t:picker-options=\"isDisabled\"\n>\n</el-date-picker>\n```\n<!-- more -->\n设置最大选择日期和最小选择日期\n```javascript\nisDisabled: {\n  disabledDate(time) {\n  \t// 大于某个日期不能选择\n  \tlet myDate = new Date();\n    let _beforeDay = myDate.setDate(new Date().getDate() - 1);\n  \treturn time.getTime() >= _beforeDay;\n    // 设置日期限制 小于某个日期不能选择\n    return time.getTime() < new Date('2019/07/25 00:00:00').getTime() - 8.64e7;\n  }\n},\n```\n"},{"title":"js String padStart()自动补全操作","url":"/2020/06/02/js-String-padStart-自动补全操作/","content":"###### 字符串自动补全函数 注意一定是字符串！\n[padStart(targetLength [, padString]) ](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/padStart)方法用另一个字符串填充当前字符串(重复，如果需要的话)，以便产生的字符串达到给定的长度。填充从当前字符串的开始(左侧)应用的。\n**targetLengt** 目标长度\n**padString** 补充的字符串\n<!-- more -->\n```javascript\nvar str1 = \"1\";\n// 补充两位 场景：日期时间\nvar _str1 = sr1.padStart(2, '0') // '01'\n\n// 补充多位 场景：单据号\nvar receiptNO = '1';\nvar _receiptNO = receiptNO.padStart(16, '0'); // '000000000000001';\n\n```\n###### 另外补充浏览器不支持的情况下需要添加Polyfill\n如果原生环境不支持该方法，在其他代码之前先运行下面的代码，将创建 String.prototype.padStart() 方法。\n```javascript\n// https://github.com/uxitten/polyfill/blob/master/string.polyfill.js\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart\nif (!String.prototype.padStart) {\n    String.prototype.padStart = function padStart(targetLength,padString) {\n        targetLength = targetLength>>0; //floor if number or convert non-number to 0;\n        padString = String((typeof padString !== 'undefined' ? padString : ' '));\n        if (this.length > targetLength) {\n            return String(this);\n        }\n        else {\n            targetLength = targetLength-this.length;\n            if (targetLength > padString.length) {\n                padString += padString.repeat(targetLength/padString.length); //append to original to ensure we are longer than needed\n            }\n            return padString.slice(0,targetLength) + String(this);\n        }\n    };\n}\n```\n"},{"title":"nrm : 无法加载文件 C: rogram Files\nodejs\nrm.ps1，因为在此系统上禁止运行脚本。","url":"/2020/06/02/nrm-无法加载文件-C-Program-Files-nodejs-nrm-ps1，因为在此系统上禁止运行脚本。/","content":"Win10系统 安装 nrm 出现报错：\nnrm : 无法加载文件 C:\\Program Files\\nodejs\\nrm.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。\n所在位置 行:1 字符: 1\n<!-- more -->\n[![ttmYss.png](https://s1.ax1x.com/2020/06/02/ttmYss.png)](https://imgchr.com/i/ttmYss)\n**解决办法：**\n1、win键 + s 搜索 powershell 并一管理员身份运行：\n[![ttmtLn.png](https://s1.ax1x.com/2020/06/02/ttmtLn.png)](https://imgchr.com/i/ttmtLn)\n2、执行以下命令：**set-ExecutionPolicy RemoteSigned** 回车；\n[![ttmJMj.png](https://s1.ax1x.com/2020/06/02/ttmJMj.png)](https://imgchr.com/i/ttmJMj)\n并按 **Y** 执行；\n3、重新安装即可；\n"},{"title":"npm 和 cnpm 以及 npm 管理工具","url":"/2020/06/02/npm-和-cnpm-以及-npm-管理工具/","content":"\n### 关于 npm 源设置\n#### 1、临时使用某个安装源地址：\n如果只想某一次使用某个安装源命令如下：\n```bash\n\t// 使用源镜像\n\tnpm --registry https://registry.npm.org install\n\t// 使用淘宝镜像\n\tnpm --registry https://registry.npm.taobao.org install\n```\n<!-- more -->\n上面两个命令 **install** 后面跟安装包名则安装指定包；不指定则按照**package.json**安装\n\n#### 2、持久使用源地址：\n如果想一直使用某一个源地址命令如下：\n```bash\n\tnpm config set registry https://registry.npm.taobao.org\n```\n配置后可通过下面方式来验证是否成功\n```bash\n\t// 如果成功则返回的是 上一步设置好的源地址；\n\t// npm config get registry 返回的是当前源地址;\n\tnpm config get registry\n\t// npm info <name> 返回的是当前安装包的信息;\n\tnpm info <安装包name>\n```\n然后就可以像往常正常使用**npm命令**\n\n#### 3、通过使用阿里的镜像cnpm使用\n使用阿里的镜像 cnpm 的执行命令：\n```bash\n\tnpm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n只需要执行上面的命令就可以像使用 npm 一样使用 cnmp了,**唯一不同就是所有npm命令都换成cnpm**；\n例：\n```bash\n\tcnpm install\n```\n#### 4、通过使用 nrm 来管理 npm 源地址：\n4-1、安装\n安装 nrm 命令：\n```bash\n\tnpm install -g nrm\n```\n安装成功之后使用 **nvm -V** 查看是否安装成功，\n如遇报错**1[请查看解决办法](https://mogugit.github.io/2020/06/02/nrm-%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6-C-Program-Files-nodejs-nrm-ps1%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%9C%A8%E6%AD%A4%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%A6%81%E6%AD%A2%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC%E3%80%82/#more)**\n\n4-2、查看当前源列表\n执行命令\n```bash\n\tnrm ls\n```\n展示如下 可以看到列表中左侧为名称，右侧为地址。带*的为当前配置：\n[![ttewgH.png](https://s1.ax1x.com/2020/06/02/ttewgH.png)](https://imgchr.com/i/ttewgH)\n更换命令 nrm use < registry> registry:代表源的名；\n例：\n```bash\n\tnrm use npm/yarn/cnpm/taobao\n```\n使用npm的 npm config list 命令查看查看当前源配置。\n```bash\n\tnpm config list\n```\n[![tteN4O.png](https://s1.ax1x.com/2020/06/02/tteN4O.png)](https://imgchr.com/i/tteN4O)\nnrm还提供了测速功能，命令为 **nrm test [registry]** ，不知道选哪个源时，可以先测一波，哪个快用哪个。不加registry时，可测所有的\n```bash\n\tnrm test\n```\n结果如下\n[![tted8e.png](https://s1.ax1x.com/2020/06/02/tted8e.png)](https://imgchr.com/i/tted8e)\n#### 命令提示：\n1. **nrm -V** ：查看当前nvm版本。\n2. **nrm -h** ：显示所有命令。\n3. **nrm current** ：显示当前源名称。\n4. **nrm use < registry>** ：切换源。\n5.  **nrm add < registry> < url> [home]** ：添加一个源。比如公司自己的私有源等。\n6.  **nrm set-auth < registry> < value> [always]** ：设置自定义源的授权信息。\n7.  **nrm set-email < registry> < value>** ：给自定义源设置路径。\n8.  **nrm set-hosted-repo < registry> < value>** ：设置发布到自定义源的npm托管仓储。\n9.   **nrm del < registry>** ：删除自定义源。\n10. **nrm home < registry> [browser]** ：浏览器中打开源首页。\n11.  **nrm publish [options] [< tarball> | < folder>]** ：发布包到自定义源，如果没有使用自定义源，则直接发布到npm。\n12.  **nrm test [registry]** ：测试源的访问速度。不加registry时，测试所有的。\n\n\n"},{"title":"js-惰性函数","url":"/2020/06/02/js-惰性函数/","content":"利用闭包思想\n原来定义一个函数来根据情况执行\n<!-- more -->\n```js\n// DOM2 事件绑定 DOM事件参考链接：DOM级别事件\n\t// 元素.addEventListener();\n\t// 元素.attachEvent();\nfunction emit(element,type,func) {\n\tif(element.addEventListener) {\n\t\telement.addEventListener(type,func,false)\n\t}else if (element.attachEvent){\n\t\telement.attachEvent('on'+type,func)\n\t} else {\n\t\telement['on'+type] = func\n\t}\n}\n\nemit(box,'click',func);\nemit(box,'click',func);\n```\n使用闭包\n```js\nfunction emit(element,type, func){\n\tif (element.addEventListener) {\n\t\temit = function(element,type,func){\n\t\t\telement.addEventListener(type,func,false)\n\t\t}\n\t} else if(element.attachEvent) {\n\t\temit = function(element,type,func){\n\t\t\telement.attachEvent('on'+type, func);\n\t\t}\n\t} else {\n\t\temit = function(element,type,func){\n\t\t\telement['on'+type] = func\n\t\t}\n\t}\n\temit(element,type,func)\n}\nemit(box,'click',func);\nemit(box,'click',func);\n```\n两者的区别\n前者在添加事件时每次都会去判断当前环境兼容性；\n而使用了闭包思想的惰性函数之后,在多次调用后，可以大大节省后面的判断步骤；\n"},{"title":"DOM 事件深入浅出","url":"/2020/06/02/DOM-事件深入浅出/","content":"#### DOM级别与DOM事件\n`DOM`级别一共可以分为4个级别：`DOM0级`，`DOM1级`，`DOM2级`和 `DOM3级`，而`DOM`事件分为3个级别：`DOM0` 级事件处理，`DOM2` 级事件处理和 `DOM3` 级事件处理。如下图所示：\n![ttpKa9.png](https://s1.ax1x.com/2020/06/02/ttpKa9.png)\n**为什么没有DOM1级事件处理呢？**\n因为1级 `DOM` 标准中并没有定义事件相关的内容，所以没有所谓的1级 `DOM` 事件模型。\n\n<!-- more -->\n#### 1.DOM0级事件\n在了解 `DOM0` 级事件之前，我们有必要先了解下 `HTML` 事件处理程序，也是最早的这一种的事件处理方式，代码如下：\n```html\n<button type=\"button\" onclick=\"showFn()\"></button>\n\n<script>\n    function showFn() {\n        alert('Hello World');\n    }\n</script>\n```\n以上代码我们通过直接在 `HTML` 代码里定义了一个 `onclick` 的属性触发 `showFn` 方法，这样的事件处理程序最大的缺点就是 `HTML` 于 `JS` 强耦合，我们一旦需要修改函数名就得修改两个地方。当然其优点是不需要操作 `DOM` 来完成事件的绑定。\n\n那么什么是`DOM0`级处理事件呢？`DOM0`级事件就是将一个函数赋值给一个事件处理属性，比如：\n```html\n<button id=\"btn\" type=\"button\"></button>\n\n<script>\n    var btn = document.getElementById('btn');\n\n    btn.onclick = function() {\n        alert('Hello World');\n    }\n\n    // btn.onclick = null; 解绑事件 释放占用内存；\n</script>\n```\n以上代码我们给 `button` 定义了一个 `id`，通过 `JS` 获取到了这个 `id` 的按钮，并将一个函数赋值给了一个事件处理属性 `onclick`，这样的方法便是 `DOM0级` 处理事件的体现。我们可以通过给事件处理属性赋值null来解绑事件。\n\n`DOM0 级`事件处理程序的缺点在于同一个处理程序无法同时绑定多个处理函数，比如我还想在按钮点击事件上加上另外一个函数。比如：\n```html\n<button id=\"btn\" type=\"button\"></button>\n\n<script>\n    var btn = document.getElementById('btn');\n\n    btn.onclick = function() {\n        alert('Hello World');\n    }  // 被覆盖，并不执行\n    btn.onclick = function() {\n        alert('Hello JavaScript');\n    }\n\n    // btn.onclick = null; 解绑事件 释放占用内存；\n</script>\n```\n#### 2.DOM2级事件\n`DOM2级` 事件在 `DOM0 级`事件的基础上弥补了一个处理程序无法同时绑定多个处理函数的缺点，允许给一个处理程序添加多个处理函数。代码如下：\n```html\n<button id=\"btn\" type=\"button\"></button>\n\n<script>\n    var btn = document.getElementById('btn');\n\n    function showFn() {\n        alert('Hello World');\n    }\n\n    btn.addEventListener('click', showFn, false);\n\n    // btn.removeEventListener('click', showFn, false); 解绑事件\n</script>\n```\n`DOM2级` 事件定义了 `addEventListener` 和 `removeEventListener` 两个方法，分别用来绑定和解绑事件，方法中包含3个参数，分别是绑定的事件处理属性名称（不包含`on`）、处理函数和是否在捕获时执行事件处理函数。如果我们还需要添加一个鼠标移入的方法，只需要：\n```js\nbtn.addEventListener('mouseover', showFn, false);\n```\n这样点击按钮和鼠标移入时都将触发`showFn`方法。\n\n需要注意的是IE8级以下版本不支持 `addEventListener` 和 `removeEventListener`，需要用attachEvent和detachEvent来实现：\n```js\nbtn.attachEvent('onclick', showFn); // 绑定事件\nbtn.detachEvent('onclick', showFn); // 解绑事件\n```\n这里我们不需要传入第三个参数，因为IE8级以下版本只支持冒泡型事件。\n\n#### 3.DOM3级事件\n`DOM3` 级事件在 `DOM2` 级事件的基础上添加了更多的事件类型，全部类型如下：\n\nUI事件，当用户与页面上的元素交互时触发，如：`load`、`scroll`\n焦点事件，当元素获得或失去焦点时触发，如：`blur`、`focus`\n鼠标事件，当用户通过鼠标在页面执行操作时触发如：`dbclick`、`mouseup`\n滚轮事件，当使用鼠标滚轮或类似设备时触发，如：`mousewheel`\n文本事件，当在文档中输入文本时触发，如：`textInput`\n键盘事件，当用户通过键盘在页面上执行操作时触发，如：`keydown`、`keypress`\n合成事件，当为IME（输入法编辑器）输入字符时触发，如：`compositionstart`\n变动事件，当底层 `DOM` 结构发生变化时触发，如：`DOMsubtreeModified`\n\n同时 `DOM3` 级事件也允许使用者自定义一些事件。\n\n#### DOM事件流\n上文中讲到了 `addEventListener` 的第三个参数为指定事件是否在捕获阶段执行，设置为 `true` 表示事件在捕获阶段执行，而设置为 `false` 表示事件在冒泡阶段执行。那么什么是事件冒泡和事件捕获呢？可以用下图来解释：\n\n![ttpuVJ.png](https://s1.ax1x.com/2020/06/02/ttpuVJ.png)\n#### 1.事件冒泡\n所谓事件冒泡就是事件像泡泡一样从最开始生成的地方一层一层往上冒，比如上图中 `a` 标签为事件目标，点击 `a` 标签后同时也会触发 `p`、`li` 上的点击事件，一层一层向上直至最外层的 `html` 或  `document`。下面是代码示例：\n```html\n<div id=\"box\">\n    <a id=\"child\">事件冒泡</a>\n</div>\n\n<script>\n var box = document.getElementById('box'),\n child = document.getElementById('child');\n\nchild.addEventListener('click', function() {\n    alert('我是目标事件');\n }, false);\n\n box.addEventListener('click', function() {\n    alert('事件冒泡至DIV');\n }, false);\n</script>\n```\n上面的代码运行后我们点击 `a` 标签，首先会弹出'我是目标事件'提示，然后又会弹出'事件冒泡至 `DIV` 的提示，这便说明了事件自内而外向上冒泡了。\n\n那么我们如何阻止事件冒泡呢？这里就涉及事件的 `Event` 对象中的 `stopPropagation` 方法，如下：\n```js\nchild.addEventListener('click', function(e) {\n    alert('我是目标事件');\n    e.stopPropagation();\n}, false);\n```\n加上 `stopPropagation` 方法后，我们再次点击 `a` 标签就不会触发 `div` 上的 `click` 事件了。\n\n#### 2.事件捕获\n和事件冒泡相反，事件捕获是自上而下执行，我们只需要将 `addEventListener` 的第三个参数改为true就行。\n```html\n<div id=\"box\">\n    <a id=\"child\">事件冒泡</a>\n</div>\n\n<script>\n var box = document.getElementById('box'),\n child = document.getElementById('child');\n\n child.addEventListener('click', function() {\n     alert('我是目标事件');\n }, true);\n\n box.addEventListener('click', function() {\n    alert('事件冒泡至DIV');\n }, true);\n</script>\n```\n此时我们点击 `a` 标签，首先弹出的是'事件冒泡至 `DIV`，其次弹出的是'我是目标事件'，正好与事件冒泡相反。\n"},{"title":"mouseover和mouseenter以及mouseout和mouseleave区别","url":"/2020/06/02/mouseover和mouseenter以及mouseout和mouseleave区别/","content":"#### 1、mouseover与mouseenter\n\n**共同点**：\n当二者都没有子元素时,二者的行为是一致的,但是二者内部都包含子元素时,行为就不同了.\n\n<!-- more -->\n**不同点：**\nmouseover事件：不论鼠标指针进入被选元素或其子元素，都会触发其父级的 \tmouseover 事件。mouseenter事件：只有在鼠标指针进入被选元素时，才会触发 mouseenter 事件。\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Document</title>\n  <style>\n    #box1 {\n      width:200px;\n      height: 200px;\n      background-color: aquamarine;\n    }\n    #box2 {\n      width:200px;\n      height: 200px;\n      background-color: brown;\n    }\n    #ch1 {\n      width:150px;\n      height: 100px;\n      background-color:cornsilk;\n      margin: 0 auto;\n    }\n    #ch2 {\n      width:150px;\n      height: 100px;\n      background-color:darkgrey;\n      margin: 0 auto;\n    }\n  </style>\n</head>\n<body>\n    <div id=\"box1\">\n      <div id=\"ch1\"></div>\n    </div>\n    <div id=\"box2\">\n      <div id=\"ch2\"></div>\n    </div>\n    <script>\n      var box1 = document.getElementById('box1');\n      var box2 = document.getElementById('box2');\n      var ch1 = document.getElementById('ch1');\n      var ch2 = document.getElementById('ch2');\n      var a = 1;\n      var b = 1;\n      var c = 1;\n      var d = 1;\n\n      function fnb1(){\n        ch1.innerText = '父节点mouseover次数' + ++a + \"\\n\" +'子节点mouseover次数'+ c;\n      }\n\n      function fnb2(){\n        ch2.innerText = '父节点mouseenter次数' + ++b + \"\\n\" +'子节点mouseenter次数'+ d;\n      }\n\n      function fnc1(){\n        ch1.innerText = '父节点mouseover次数' + a + \"\\n\" +'子节点mouseover次数'+ ++c;\n      }\n\n      function fnc2(){\n        ch2.innerText = '父节点mouseenter次数' + b + \"\\n\" +'子节点mouseenter次数'+ ++d;\n      }\n\n      box1.addEventListener('mouseover', fnb1,false)\n      box2.addEventListener('mouseenter', fnb2,false)\n\n      ch1.addEventListener('mouseover', fnc1,false)\n      ch2.addEventListener('mouseenter', fnc2,false)\n    </script>\n</body>\n</html>\n```\n页面展示如下：\n[![ttSO8P.png](https://s1.ax1x.com/2020/06/02/ttSO8P.png)](https://imgchr.com/i/ttSO8P)\n#### 2、mouseout和mouseleave\n**共同点：**\n当二者都没有子元素时,二者的行为是一致的,但是二者内部都包含子元素时,行为就不同了.\n**不同点：**\nmouseout事件：不论鼠标指针离开被选元素还是任何子元素，都会触发 mouseout 事件。\nmouseleave事件：只有在鼠标指针离开被选元素时，才会触发 mouseleave 事件。\n\n效果和上面一样这里就不演示代码了 。\n"},{"title":"js-compose函数","url":"/2020/06/02/js-compose函数/","content":"#### compose函数\n将函数扁平化处理\n```js\nfunction fn1(x){\n\treturn x + 1;\n}\nfunction fn2(x){\n\treturn x + 10;\n}\nfunction fn3(x){\n\treturn x*10;\n}\nfunction fn4(x){\n\treturn x/10;\n}\n// fn1执行然后结果作为fn2参数 一直执行到fn4;\nfn4(fn3(fn2(fn1(5)))) // 16\n```\n\n<!-- more -->\n但是这么写太麻烦了 所以可以简化为这样 使用[reduce 函数](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array/reduce)\n```js\nfunction compose(...funs){\n\treturn function proxy(...args){\n\t\tlet len = funs.length;\n\t\tif(len===0){\n\t\t\treturn args;\n\t\t}\n\t\tif(len === 1){\n\t\t\treturn funs[0](...args);\n\t\t}\n\t\treturn funs.reduce((x,y)=>{\n\t\t\treturn typeof x === 'function' ? y(x(...args)) : y(x);\n\t\t})\n\t}\n}\ncompose()(5); // [5]\ncompose(fn1,fn2,fn3,fn4)(5) // 16\n```\n"},{"title":"面试题-函数原型","url":"/2020/06/02/面试题-函数原型/","content":"###### 关于原型函数的问题:\n```js\n\tfunction Foo(){\n\t\tgetName = function(){\n\t\t\tconsole.log(1)\n\t\t}\n\t\treturn this;\n\t}\n\n\tFoo.getName = function(){\n\t\tconsole.log(2)\n\t}\n\n\tFoo.prototype.getName = function(){\n\t\tconsole.log(3)\n\t}\n\n\tvar getName = function(){\n\t\tconsole.log(4)\n\t}\n\n\tfunction getName(){\n\t\tconsole.log(5)\n\t}\n\n\tFoo.getName();\n\tgetName();\n\tFoo().getName();\n\tgetName();\n\tnew Foo.getName();\n\tnew Foo().getName();\n\tnew new Foo().getName();\n```\n\n<!-- more -->\n###### 分析：代码执行 存在var 和匿名函数 所以变量提升 以下函数被提升到顶部；\n```js\ngetName = function(){\n\tconsole.log(5)\n}\n```\n###### 函数执行\n1) 执行 Foo 的 getName 方法 输出；\n```js\n\tFoo.getName() // 2；\n```\n2) 执行的是 var getName = ... 会将提升的函数覆盖；\n```js\n\tgetName() // 4\n```\n3) 执行 Foo 函数之后又覆盖 getName, 接着调用 getName 函数，此时调用getName函数；\n```js\n\tFoo().getName() // 1\n```\n4) 执行 getName() 此时函数还是执行上一步的函数；\n```js\n\tgetName() // 1\n```\n5) 此函数执行是考察[运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)；\n```js\n\tnew Foo.getName() // => new (Foo.getName)()  输出 2；\n```\n6) 此函数执行同样考察[运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence), 但是此时new Foo() 是执行Foo的实例 由于Foo 实例里面没有getName 方法，所以会去原型上找protoType；\n```js\n\tnew Foo().getName() // => (new Foo()).getName() 输出 3\n```\n7) 此函数执行同样考察[运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence), 是前面两个的综合；\n```js\nnew new Foo().getName() // => new ((new Foo()).getName)() // 3\n```\n"},{"title":"面试题-js基础2","url":"/2020/06/02/面试题-js基础2/","content":"面试题：当 a 等于什么的时候下面的代码成立？\n```js\n\t// 问： 当 a 等于什么的时候下面的代码成立\n\tvar a = ?;\n\tif (a == 1 && a == 2 && a == 3){\n\t\tconsole.log('OK')\n\t}\n```\n\n<!-- more -->\n方案一：利用比较的时候调用 toString() 方法，来重写 toString() 方法；\n```js\n\t// 写法一：\n\tvar a = {\n\t\ti: 0,\n\t\ttoString(){\n\t\t\treturn ++this.i;\n\t\t}\n\t}\n\n\tif (a == 1 && a == 2 && a == 3) {\n\t\tconsole.log('OK')\n\t} // OK\n\n\t// 写法二：\n\tvar a = [1,2,3];\n\ta.toString = a.shift;\n\n\tif (a == 1 && a == 2 && a == 3) {\n\t\tconsole.log('OK')\n\t} // OK\n```\n方案二：利用[Objext.defineProperty()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) 来拦截，并改变值；\n```js\n\tlet i = 0;\n\tObject.defineProperty(window, 'a', {\n\t\tget(){\n\t\t\treturn ++i;\n\t\t},\n\t\tset(){\n\t\t}\n\t})\n\tif (a == 1 && a == 2 && a == 3) {\n\t\tconsole.log('OK')\n\t} // OK\n```\n###### [关于比较的小知识](https://www.cnblogs.com/litsword/archive/2010/07/22/1782933.html)\n==， 两边值类型不同的时候，要先进行类型转换，再比较。\n===，不做类型转换，类型不同的一定不等。\nNaN 与任何值都不相等(包括 NaN)，不管是双等还是恒等;\n```js\n NaN == NaN // false\n NaN === NaN // false\n```\n\n具体如下：\n**关于 === ：**\n1) 如果类型不同，就不相等\n2) 如果两个都是数值，并且是同一个值，那么相等(NaN 除外)；\n3) 如果两个都是字符串，每个位置的字符都一样，那么相等；否则不相等。\n4) 如果两个值都是true，或者都是false，那么相等。\n5) 如果两个值都引用同一个对象或函数，那么相等；否则[相等。\n6) 如果两个值都是null，或者都是undefined，那么相等。\n\n**关于  == :**\n1) 如果两个值类型相同，进行 === 比较。\n2) 如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较：\na) 如果一个是null、一个是undefined，那么相等。\nb) 如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。\nc) 如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。\nd) 如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的toString或者valueOf方法。 js核心内置类，会尝试valueOf先于toString；\ne) 任何其他组合，都不相等。\n```js\n\tfalse == 1 // 会先把 false 转化为数字 0 然后比较\n\t1 ==  true // 会先把 true 转化为数字 1 然后比较\n```\n\n**总结就是如下：**\n**1) NaN 和谁都不相等;\n2) null和undefind 两个等号相等 三个等号不相等;\n3) 对象 == 字符串, 会把对象转化为字符串 (对象.toString());\n4) 其余情况都是转化为数字进行比较 对象转化为数字 Number(对象.toString());**\n"},{"title":"面试题-js基础","url":"/2020/06/02/面试题-js基础/","content":"下面的代码输出结果是：\n```js\n  let obj = {\n    2:3,\n    3:4,\n    length: 2,\n    push: Array.prototype.push\n  }\n\n  obj.push(1);\n  obj.push(2);\n  console.log(obj)\n```\n<!-- more -->\n分析：\nobj是一个对象里面有四个属性，包括push 方法，正常情况下对象是没有push() 方法的，那么push()方法做什么？或者怎么实现一个 push() 方法？\n如下：\n```js\n\t// 实现简易版 push() 方法, 原理：在数组的末尾添加传入的值，改变数组长度并返回数组;\n\tArray.prototype.push = function(num){\n\t\t// this 指向当前Array\n\t\t// 默认会使 length 属性加1, 如果没有 length 属性那么 push() 方法会默认 length为0；\n\t\tthis.length = this.length || 0;\n\t\treturn this[this.length] = num;\n\t}\n\tlet arr = [1,2];\n\tarr.push(3); // => arr = [1,2,3];\n```\n通过上面的 push() 解析，可以得知：\n```js\n\tobj.push(1) // => 执行this[this.length] length为2 this[2] = 1;\n\tobj.push(2) // => 执行this[this.length] length为3 this[3] = 2;\n\tconsole.log(obj) // => obj = {2:1, 3:2, length: 4, push: Array.prototype.push}\n```\n\n\n\n"},{"title":"谈谈 Object.prototype.toString","url":"/2020/06/02/谈谈-Object-prototype-toString/","content":"#### ECMAScript 5\n在ECMAScript 5中，Object.prototype.toString()被调用时，会进行如下步骤：\n- 如果 `this` 是 `undefined` ，返回 `object Undefined` ；\n- 如果 `this `是 `null` ， 返回 `object Null` ；\n- 令 `O` 为以 `this` 作为参数调用 `ToObject`的结果；\n- 令 `class` 为 `O` 的内部属性 `[[Class]]` 的值；\n- 返回三个字符串 \"[`object\"`, `class`, 以及`\"]\"` 拼接而成的字符串。\n#### [[Class]]\n`[[Class]]` 是一个内部属性，值为一个类型字符串，可以用来判断值的类型。\n\n<!-- more -->\n有这么一段详细的解释：\n>本规范的每种内置对象都定义了 [[Class]] 内部属性的值。宿主对象的 [[Class]] 内部属性的值可以是除了 “Arguments”, “Array”, “Boolean”, “Date”, “Error”, “Function”, “JSON”, “Math”, “Number”, “Object”, “RegExp”, “String” 的任何字符串。[[Class]] 内部属性的值用于内部区分对象的种类。注，本规范中除了通过 Object.prototype.toString ( 见 15.2.4.2) 没有提供任何手段使程序访问此值。\n\n在JavaScript代码里，唯一可以访问该属性的方法就是通过 `Object.prototype.toString` ，通常方法如下：\n```js\n\tObject.prototype.toString.call(value)\n```\n例：\n```js\n\tObject.prototype.toString.call(null)\n\t// => '[object Null]'\n\n\tObject.prototype.toString.call(undefined)\n\t// => '[object Undefined]'\n\n\tObject.prototype.toString.call(Math)\n\t// => '[object Math]'\n\n\tObject.prototype.toString.call({})\n\t// => '[object Object]'\n\n\tObject.prototype.toString.call([])\n\t// => '[object Array]'\n\n\tObject.prototype.toString.call(0)\n\t// => '[object Number]'\n\n\tObject.prototype.toString.call(NaN)\n\t// => '[object Number]'\n\n\tObject.prototype.toString.call('')\n\t// => '[object String]'\n```\n因此，可以用下列函数，来获取任意变量的`[[Class]]`属性：\n```js\n\tfunction getType (val) {\n\t  const _str = Object.prototype.toString.call(val)\n\t  return /^\\[object (.*)\\]$/.exec(_str)[1]\n\t}\n```\n运行：\n```js\n\tgetClass(null)\n\t// => 'Null'\n\n\tgetClass(undefined)\n\t// => 'Undefined'\n\n\tgetClass(Math)\n\t// => 'Math'\n\n\tgetClass({})\n\t// => 'Object'\n\n\tgetClass([])\n\t// => 'Array'\n```\n#### ECMAScript 6\n在ES6，调用 `Object.prototype.toString` 时，会进行如下步骤：\n- 如果 `this` 是 `undefined` ，返回 `'[object Undefined]' `;\n- 如果 `this` 是 `null` , 返回 `'[object Null]'` ；\n- 令 `O` 为以 `this` 作为参数调用 `ToObject` 的结果；\n- 令 `isArray` 为 `IsArray(O)` ；\n- `ReturnIfAbrupt(isArray)` （如果 `isArray` 不是一个正常值，比如抛出一个错误，中断执行）；\n- 如果 `isArray` 为 `true` ， 令 `builtinTag` 为 `'Array'` ;\n- `else` ，如果 `O is an exotic String object` ， 令 `builtinTag` 为 `'String'` ；\n- `else` ，如果 `O` 含有 `[[ParameterMap]] internal slo`, ， 令 `builtinTag 为 'Arguments'` ；\n- `else` ，如果 `O` 含有 `[[Call]] internal method` ， 令 `builtinTag` 为 `Function` ；\n- `else` ，如果 `O` 含有 `[[ErrorData]] internal slot` ， 令 `builtinTag 为 `Error` ；\n- `else` ，如果 `O` 含有 `[[BooleanData]] internal slot` ， 令 `builtinTag` 为 `Boolean` ；\n- `else` ，如果 `O` 含有 `[[NumberData]] internal slot` ， 令 `builtinTag` 为 `Number` ；\n- `else` ，如果 `O` 含有 `[[DateValue]] internal slot` ， 令 `builtinTag 为 Date` ；\n- `else` ，如果 `O` 含有 `[[RegExpMatcher]] internal slot` ， 令 `builtinTag` 为 `RegExp` ；\n- `else` ， 令 `builtinTag` 为 `Object` ；\n- 令 `tag` 为 `Get(O, @@toStringTag)` 的返回值（ `Get(O, @@toStringTag`) 方法，既是在 `O` 是一个对象，并且具有 `@@toStringTag` 属性时，返回 `O[Symbol.toStringTag]` ）；\n- `ReturnIfAbrupt(tag)` ，如果 `tag` 是正常值，继续执行下一步；\n- 如果 `Type(tag) `不是一个字符串，`let tag be builtinTag` ；\n- 返回由三个字符串 `\"[object\", tag, and \"]\"` 拼接而成的一个字符串。\n\n在ES6里，之前的` [[Class]]` 不再使用，取而代之的是一系列的 `internal slot` ，有一个比较完整的解释：\n>Internal slots correspond to internal state that is associated with objects and used by various ECMAScript specification algorithms. Internal slots are not object properties and they are not inherited. Depending upon the specific internal slot specification, such state may consist of values of any ECMAScript language type or of specific ECMAScript specification type values\n\n大概的意思是：Internal slots 对应于与对象相关联并由各种ECMAScript规范算法使用的内部状态，它们没有对象属性，也不能被继承，根据具体的 Internal slot 规范，这种状态可以由任何ECMAScript语言类型或特定ECMAScript规范类型值的值组成。\n\n此外，通过对 Object.prototype.toString 在ES6的实现步骤分析，我们其实可以很容易改变 Object.prototype.toString.call 的结果，像下面一样：\n```js\n\tlet obj = {}\n\n\tObject.defineProperty(obj, Symbol.toStringTag, {\n\t    get: function() {\n\t        return \"newClass\"\n\t    }\n\t})\n\n\tconsole.log(Object.prototype.toString.call(obj)) // \"[object newClass]\"\n```\n#### 参考：\n1) [http://www.ecma-international.org/ecma-262/5.1](http://www.ecma-international.org/ecma-262/5.1)\n2) [http://www.adobe.com/devnet/archive/html5/articles/categorizing-values-in-javascript.html](http://www.adobe.com/devnet/archive/html5/articles/categorizing-values-in-javascript.html)\n3) [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString)\n4) [http://www.ecma-international.org/ecma-262/6.0/](http://www.ecma-international.org/ecma-262/6.0/)\n5) [http://es6.ruanyifeng.com/#docs/symbol](http://es6.ruanyifeng.com/#docs/symbol)\n6) [https://tc39.github.io/ecma262/#sec-object.prototype.tostring](https://tc39.github.io/ecma262/#sec-object.prototype.tostring)\n"},{"title":"判断一个对象是否为空","url":"/2020/06/02/判断一个对象是否为空/","content":"\n#### 如何判断一个对象是否为空\n1、利用 `Object.keys` 方法 该方法会返回当前对象内所有返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（`enumerable`）属性的键名。[详情 `Object.keys`](https://es6.ruanyifeng.com/#docs/object-methods)；\n**如果数组的长度不为空那么则说明对象不为空**\n使用方法如下：\n<!-- more -->\n```js\n\tconst obj = { name: '张三', age: 18, sex: '男' };\n\tlet arr = Object.keys(obj); // ['name', 'age', 'sex']\n\n\tif(arr.length){\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n```\n抽成方法：\n```js\n\tfunction checkObj(obj){\n\t\tif (typeof obj != 'object') thorw new Error('参数不是一个可遍历对象');\n\t\tlet _arr = Object.keys(obj);\n\t\treturn !!_arr.length;\n\t}\n\tvar obj = {};\n\tcheckObj(obj) // false\n\n\tobj = { name: '张三' }\n\tcheckObj(obj) // true\n\n\tobj = [];\n\tcheckObj(obj) // false\n\n\tobj = [1];\n\tcheckObj(obj); // true\n\n\tobj = function(){};\n\tcheckObj(obj) // Uncaught Error: 参数不是可遍历对象;\n```\n2、使用`for...in` 循环，如果对象可循环那么不为空，否则为空对象 ；**前提：对象属性是可遍历**：\n```js\n\tfunction checkObj(obj){\n\t\tfor(let item in obj){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tvar obj = {};\n\tcheckObj(obj) // false\n\tobj = {name:'张三'}\n\tcheckObj(obj);\n\tobj = [];\n\tcheckObj(obj);\n\tobj = [1];\n\tcheckObj(obj);\n\tobj = function(){}\n\tcheckObj(obj) // false\n```\n","tags":["util"]},{"title":"css background属性合在一起写background-size background-positon","url":"/2020/06/02/css-background属性合在一起写background-size-background-positon/","content":"```css\nbackground: no-repeat scroll 56px 78px / 69px 69px rgba(0, 0, 0, 0) url('.....');\n\nbackground: no-repeat scroll `56px 78px（background-position）/（分割线） *69px 69px *（background-size ）` rgba(0, 0, 0, 0);\n```\n\n<!-- more -->\n","tags":["css","background"]},{"title":"个人上网工具搭建","url":"/2020/06/02/个人上网工具搭建/","content":"\nubantu 20.06 ss服务 两步走\n```shell\n\tdocker pull mritd/shadowsocks\n```\n如果提示 `docker` 没有， 那么安装一下\n```shell\n  apt install docker.io\n```\n<!-- more -->\n```shell\n\tdocker run -dt --name ss -p 16443:16443 mritd/shadowsocks -s \"-s 0.0.0.0 -p 16443 -m aes-256-cfb -k test1231. --fast-open\"\n```\ntest1231.   ->  password\n\n--------------------------------------华丽丽的分割线-------------------------------------------------\n## ==服务器为centos 6==\n### 一、搭建ss\n1、用xshell或者putty等工具远程登录服务器，要用root账户登录，运行以下命令(按顺序执行)：\n```\n(1)yum install -y wget\n(2) wget –no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\n(3) chmod +x shadowsocks.sh\n(4) ./shadowsocks.sh 2>&1 | tee shadowsocks.log\n```\n安装完成后，会提示你设置密码,端口,加密方式；\n\n会有如下提示\n>Congratulations, Shadowsocks-python server install completed! Your Server IP :your_server_ip Your Server Port :your_server_port Your Password :your_password Your Encryption Method:your_encryption_method Welcome to visit:https://teddysun.com/342.html Enjoy it!\n\n安装完成之后的查看配置信息 ：vi /etc/shadowsocks.json\n展示如下：\n```java\n{\n\t“server”:”0.0.0.0″,\n\t“server_port”:8989,\n\t“local_address”:”127.0.0.1″,\n\t“local_port”:1080,\n\t“password”:”yourpassword”,\n\t“timeout”:300,\n\t“method”:”camellia-256-cfb”,\n\t“fast_open”:false\n}\n```\n常用命令：\n>卸载：./shadowsocks.sh uninstall\n启动：/etc/init.d/shadowsocks start\n停止：/etc/init.d/shadowsocks stop\n重启：/etc/init.d/shadowsocks restart\n状态：/etc/init.d/shadowsocks status\n\n电脑上安装对应的shadowsocks客户端\n(1)我的是win10系统，照例还是给个链接\n \t[windows版本：https://github.com/shadowsocks/shadowsocks-windows/releases](https://github.com/shadowsocks/shadowsocks-windows/releases)\n \t[mac版本：https://github.com/shadowsocks/shadowsocks-iOS/releases](https://github.com/shadowsocks/shadowsocks-iOS/releases )\n \t[android版本：https://github.com/shadowsocks/shadowsocks-android](https://github.com/shadowsocks/shadowsocks-android)\n \t(我用的是shadowsocks-arm64-v8a-4.6.1.apk这个版本，其他几个不行，不知道为什么)\n (2)下载好后打开运行，电脑任务栏会有一个小飞机，双击，填写配置参数(vi /etc/shadowsocks.json  这个命令打印出来的信息);\n\n2、开放多端口，配置ss多用户 之前的ss配置文件内如大概如下：\n```java\n{\n  \"server\": \"0.0.0.0\",\n  \"server_port\": 8989,\n  \"password\": \"password1\",\n  \"method\": \"camellia-256-cfb\",\n  \"local_address\":\"127.0.0.1\",\n  \"local_port\":1080,\n  \"timeout\":300,\n  \"fast_open\":false\n}\n```\n我们修改ss配置文件 vi /etc/shadowsocks.json\n>IV ,IVM编辑 退出方法\n:WQ   保存退出\n:X\n:Q    不保存退出\nU撤销，ctrl+R 恢复。\n\n```java\n{\n    \"server\": \"0.0.0.0\",\n    \"port_password\": {\n        \"8989\":\"password1\",\n        \"8888\":\"password2\",\n        \"9999\":\"password3\"\n    },\n    \"timeout\": 300,\n    \"method\": \"camellia-256-cfb\",\n    \"local_address\":\"127.0.0.1\",\n    \"local_port\":1080,\n    \"timeout\":300,\n    \"fast_open\":false\n}\n```\n将此文件先备份到本地（以便ss客户端使用） 然后重新启动ss服务：\n\t(1) 备份\n```\n\t/etc/init.d/shadowsocks restart\n```\n这时增加的端口还不能使用，因为防火墙未开放新增的端口 开放端口的方法：\n\t1）打开防火墙配置文件:\n```\n\tvi /etc/sysconfig/iptables\n```\n\n2）加入以下两句\n```\n\t-A INPUT -p udp -m state --state NEW -m udp --dport 8888 -j ACCEPT\n\t-A INPUT -p tcp -m state --state NEW -m tcp --dport 8888 -j ACCEPT\n```\n\n3）重启防火墙使配置生效\n```\n\tservice iptables restart\n```\n现在可以尝试在客户端设置不同的端口，看看能不能fan墙了~\n\n### 二、使用锐速提速\n虽然现在可以访问google，看到墙外的世界了，但是，速度是有点慢。。\n1、更换内核 一键更换内核脚本（[vultr](https://my.vultr.com)需先执行此脚本）\n```\n\twget –N —no–check–certificate https://freed.ga/kernel/ruisu.sh && bash ruisu.sh\n```\n注意：脚本执行过程中，请勿进行任何操作。不要觉得它怎么就卡住了，这个过程可能有点长，待服务器重启后，本次连接将终端，重新ssh连接服务器安装锐速即可。\n\n2、执行锐速一键安装脚本：\n```\n\twget –N —no–check–certificate https://github.com/91yun/serverspeeder/raw/master/serverspeeder.sh && bash serverspeeder.sh\n```\n**_若提示：The name of network interface is not eth0, please retry after changing the name.\n请使用备用脚本：\nwget –N —no–check–certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder-all.sh && bash serverspeeder-all.sh_**\n若执行成功，将看到类似以下：\n![执行命令成功](https://img-blog.csdnimg.cn/20191105203106272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseV93dWd1aQ==,size_16,color_FFFFFF,t_70)\n下面是锐速常用的一些命令：\n>启动：/serverspeeder/bin/serverSpeeder.sh start\n停止：/serverspeeder/bin/serverSpeeder.sh stop\n状态：service serverSpeeder status\n\n## ==Centos7的搭建教程==\n### 一、搭建ss服务\n1) 下载安装\n```\n wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\n```\n2) 修改目录权限 赋可执行权限\n```\n\tchmod +x shadowsocks.sh\n```\n3）运行程序，记录日志\n```\n\t./shadowsocks.sh 2>&1 | tee shadowsocks.log\n```\n```java\n#############################################################\n# One click Install Shadowsocks-Python server               #\n# Intro: https://teddysun.com/342.html                      #\n# Author: Teddysun <i@teddysun.com>                         #\n# Github: https://github.com/shadowsocks/shadowsocks        #\n#############################################################\n\nPlease enter password for shadowsocks-python\n(Default password: teddysun.com):xxx\n\n---------------------------\npassword = xxx\n---------------------------\n\nPlease enter a port for shadowsocks-python [1-65535]\n(Default port: xxx):\n\n---------------------------\nport = xxx\n---------------------------\n\nPlease select stream cipher for shadowsocks-python:\n1) aes-256-gcm\n2) aes-192-gcm\n3) aes-128-gcm\n4) aes-256-ctr\n5) aes-192-ctr\n6) aes-128-ctr\n7) aes-256-cfb\n8) aes-192-cfb\n9) aes-128-cfb\n10) camellia-128-cfb\n11) camellia-192-cfb\n12) camellia-256-cfb\n13) chacha20-ietf-poly1305\n14) chacha20-ietf\n15) chacha20\n16) rc4-md5\nWhich cipher you'd select(Default: aes-256-gcm):7\n\n---------------------------\ncipher = aes-256-cfb\n---------------------------\n\n\nPress any key to start...or Press Ctrl+C to cancel\nIgn http://http.us.debian.org jessie InRelease\nHit http://http.us.debian.org jessie-updates InRelease\nHit http://http.us.debian.org jessie Release.gpg\nHit http://http.us.debian.org jessie-updates/main Sources\nGet:1 http://http.us.debian.org jessie-updates/main amd64 Packages/DiffIndex [10.9 kB]\nGet:2 http://http.us.debian.org jessie-updates/main Translation-en/DiffIndex [3688 B]\nHit http://http.us.debian.org jessie Release\nHit http://http.us.debian.org jessie/main Sources\nHit http://http.us.debian.org jessie/main amd64 Packages\nHit http://http.us.debian.org jessie/main Translation-en\nHit http://security.debian.org jessie/updates InRelease\nHit http://security.debian.org jessie/updates/main Sources\nHit http://security.debian.org jessie/updates/main amd64 Packages\nHit http://security.debian.org jessie/updates/main Translation-en\nFetched 14.5 kB in 4s (3370 B/s)\nReading package lists...\nReading package lists...\nBuilding dependency tree...\nReading state information...\nautoconf is already the newest version.\nautomake is already the newest version.\ngcc is already the newest version.\nlibtool is already the newest version.\nmake is already the newest version.\npython is already the newest version.\npython-dev is already the newest version.\npython-setuptools is already the newest version.\nunzip is already the newest version.\nwget is already the newest version.\ncurl is already the newest version.\nlibssl-dev is already the newest version.\nopenssl is already the newest version.\nopenssl set to manually installed.\n0 upgraded, 0 newly installed, 0 to remove and 8 not upgraded.\nconverted 'https://github.com/jedisct1/libsodium/releases/download/1.0.16/libsodium-1.0.16.tar.gz' (ANSI_X3.4-1968) -> 'https://github.com/jedisct1/libsodium/releases/download/1.0.16/libsodium-1.0.16.tar.gz' (UTF-8)\n--2018-03-30 08:00:14--  https://github.com/jedisct1/libsodium/releases/download/1.0.16/libsodium-1.0.16.tar.gz\nResolving github.com (github.com)... 13.250.177.223, 13.229.188.59, 52.74.223.119\nConnecting to github.com (github.com)|13.250.177.223|:443... connected.\nHTTP request sent, awaiting response... 302 Found\nLocation: https://github-production-release-asset-2e65be.s3.amazonaws.com/7710647/83a2fc2c-e01e-11e7-93d1-34e5a92f4011?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20180330%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20180330T080014Z&X-Amz-Expires=300&X-Amz-Signature=b1c25d7f46c71228586cd8d85265ba26f7f5d894b4bcf733fda382362a95fb4b&X-Amz-SignedHeaders=host&actor_id=0&response-content-disposition=attachment%3B%20filename%3Dlibsodium-1.0.16.tar.gz&response-content-type=application%2Foctet-stream [following]\nconverted 'https://github-production-release-asset-2e65be.s3.amazonaws.com/7710647/83a2fc2c-e01e-11e7-93d1-34e5a92f4011?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20180330%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20180330T080014Z&X-Amz-Expires=300&X-Amz-Signature=b1c25d7f46c71228586cd8d85265ba26f7f5d894b4bcf733fda382362a95fb4b&X-Amz-SignedHeaders=host&actor_id=0&response-content-disposition=attachment%3B%20filename%3Dlibsodium-1.0.16.tar.gz&response-content-type=application%2Foctet-stream' (ANSI_X3.4-1968) -> 'https://github-production-release-asset-2e65be.s3.amazonaws.com/7710647/83a2fc2c-e01e-11e7-93d1-34e5a92f4011?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A/20180330/us-east-1/s3/aws4_request&X-Amz-Date=20180330T080014Z&X-Amz-Expires=300&X-Amz-Signature=b1c25d7f46c71228586cd8d85265ba26f7f5d894b4bcf733fda382362a95fb4b&X-Amz-SignedHeaders=host&actor_id=0&response-content-disposition=attachment; filename=libsodium-1.0.16.tar.gz&response-content-type=application/octet-stream' (UTF-8)\n--2018-03-30 08:00:15--  https://github-production-release-asset-2e65be.s3.amazonaws.com/7710647/83a2fc2c-e01e-11e7-93d1-34e5a92f4011?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A/20180330/us-east-1/s3/aws4_request&X-Amz-Date=20180330T080014Z&X-Amz-Expires=300&X-Amz-Signature=b1c25d7f46c71228586cd8d85265ba26f7f5d894b4bcf733fda382362a95fb4b&X-Amz-SignedHeaders=host&actor_id=0&response-content-disposition=attachment;%20filename=libsodium-1.0.16.tar.gz&response-content-type=application/octet-stream\nResolving github-production-release-asset-2e65be.s3.amazonaws.com (github-production-release-asset-2e65be.s3.amazonaws.com)... 52.216.227.8\nConnecting to github-production-release-asset-2e65be.s3.amazonaws.com (github-production-release-asset-2e65be.s3.amazonaws.com)|52.216.227.8|:443... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 1910835 (1.8M) [application/octet-stream]\nSaving to: 'libsodium-1.0.16.tar.gz'\n\n     0K .......... .......... .......... .......... ..........  2% 41.2K 44s\n    50K .......... .......... .......... .......... ..........  5% 44.0K 42s\n   100K .......... .......... .......... .......... ..........  8% 70.9K 35s\n   150K .......... .......... .......... .......... .......... 10% 67.3K 32s\n   200K .......... .......... .......... .......... .......... 13% 70.9K 29s\n   250K .......... .......... .......... .......... .......... 16% 75.0K 27s\n   300K .......... .......... .......... .......... .......... 18% 70.9K 25s\n   350K .......... .......... .......... .......... .......... 21%  106K 23s\n   400K .......... .......... .......... .......... .......... 24%  106K 21s\n   450K .......... .......... .......... .......... .......... 26%  212K 19s\n   500K .......... .......... .......... .......... .......... 29%  184K 18s\n   550K .......... .......... .......... .......... .......... 32%  213K 16s\n   600K .......... .......... .......... .......... .......... 34%  213K 15s\n   650K .......... .......... .......... .......... .......... 37%  253K 13s\n   700K .......... .......... .......... .......... .......... 40%  214K 12s\n   750K .......... .......... .......... .......... .......... 42%  645K 11s\n   800K .......... .......... .......... .......... .......... 45%  313K 10s\n   850K .......... .......... .......... .......... .......... 48%  433K 9s\n   900K .......... .......... .......... .......... .......... 50%  419K 8s\n   950K .......... .......... .......... .......... .......... 53%  214K 8s\n  1000K .......... .......... .......... .......... .......... 56% 15.8M 7s\n  1050K .......... .......... .......... .......... .......... 58%  216K 6s\n  1100K .......... .......... .......... .......... .......... 61% 24.2M 6s\n  1150K .......... .......... .......... .......... .......... 64%  663K 5s\n  1200K .......... .......... .......... .......... .......... 66%  314K 5s\n  1250K .......... .......... .......... .......... .......... 69% 1.32M 4s\n  1300K .......... .......... .......... .......... .......... 72%  255K 4s\n  1350K .......... .......... .......... .......... .......... 75% 23.2M 3s\n  1400K .......... .......... .......... .......... .......... 77% 1.33M 3s\n  1450K .......... .......... .......... .......... .......... 80%  253K 2s\n  1500K .......... .......... .......... .......... .......... 83% 19.8M 2s\n  1550K .......... .......... .......... .......... .......... 85% 1.36M 2s\n  1600K .......... .......... .......... .......... .......... 88%  255K 1s\n  1650K .......... .......... .......... .......... .......... 91% 27.8M 1s\n  1700K .......... .......... .......... .......... .......... 93% 1.36M 1s\n  1750K .......... .......... .......... .......... .......... 96% 1.24M 0s\n  1800K .......... .......... .......... .......... .......... 99%  316K 0s\n  1850K .......... ......                                     100% 19.3M=10s\n\n2018-03-30 08:00:26 (180 KB/s) - 'libsodium-1.0.16.tar.gz' saved [1910835/1910835]\n\nconverted 'https://github.com/shadowsocks/shadowsocks/archive/master.zip' (ANSI_X3.4-1968) -> 'https://github.com/shadowsocks/shadowsocks/archive/master.zip' (UTF-8)\n--2018-03-30 08:00:26--  https://github.com/shadowsocks/shadowsocks/archive/master.zip\nResolving github.com (github.com)... 13.229.188.59, 52.74.223.119, 13.250.177.223\nConnecting to github.com (github.com)|13.229.188.59|:443... connected.\nHTTP request sent, awaiting response... 302 Found\nLocation: https://codeload.github.com/shadowsocks/shadowsocks/zip/master [following]\nconverted 'https://codeload.github.com/shadowsocks/shadowsocks/zip/master' (ANSI_X3.4-1968) -> 'https://codeload.github.com/shadowsocks/shadowsocks/zip/master' (UTF-8)\n--2018-03-30 08:00:26--  https://codeload.github.com/shadowsocks/shadowsocks/zip/master\nResolving codeload.github.com (codeload.github.com)... 13.250.162.133, 13.229.189.0, 54.251.140.56\nConnecting to codeload.github.com (codeload.github.com)|13.250.162.133|:443... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 114904 (112K) [application/zip]\nSaving to: 'shadowsocks-master.zip'\n\n     0K .......... .......... .......... .......... .......... 44% 7.12M 0s\n    50K .......... .......... .......... .......... .......... 89%  217K 0s\n   100K .......... ..                                         100% 17.6M=0.2s\n\n2018-03-30 08:00:27 (472 KB/s) - 'shadowsocks-master.zip' saved [114904/114904]\n\nconverted 'https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-debian' (ANSI_X3.4-1968) -> 'https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-debian' (UTF-8)\n--2018-03-30 08:00:27--  https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-debian\nResolving raw.githubusercontent.com (raw.githubusercontent.com)... 151.101.8.133\nConnecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.8.133|:443... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 1938 (1.9K) [text/plain]\nSaving to: '/etc/init.d/shadowsocks'\n\n     0K .                                                     100% 9.74M=0s\n\n2018-03-30 08:00:27 (9.74 MB/s) - '/etc/init.d/shadowsocks' saved [1938/1938]\n\nrunning install\nrunning bdist_egg\nrunning egg_info\ncreating shadowsocks.egg-info\nwriting shadowsocks.egg-info/PKG-INFO\nwriting top-level names to shadowsocks.egg-info/top_level.txt\nwriting dependency_links to shadowsocks.egg-info/dependency_links.txt\nwriting entry points to shadowsocks.egg-info/entry_points.txt\nwriting manifest file 'shadowsocks.egg-info/SOURCES.txt'\nreading manifest file 'shadowsocks.egg-info/SOURCES.txt'\nreading manifest template 'MANIFEST.in'\nwriting manifest file 'shadowsocks.egg-info/SOURCES.txt'\ninstalling library code to build/bdist.linux-x86_64/egg\nrunning install_lib\nrunning build_py\ncreating build\ncreating build/lib.linux-x86_64-2.7\ncreating build/lib.linux-x86_64-2.7/shadowsocks\ncopying shadowsocks/lru_cache.py -> build/lib.linux-x86_64-2.7/shadowsocks\ncopying shadowsocks/udprelay.py -> build/lib.linux-x86_64-2.7/shadowsocks\ncopying shadowsocks/eventloop.py -> build/lib.linux-x86_64-2.7/shadowsocks\ncopying shadowsocks/common.py -> build/lib.linux-x86_64-2.7/shadowsocks\ncopying shadowsocks/shell.py -> build/lib.linux-x86_64-2.7/shadowsocks\ncopying shadowsocks/local.py -> build/lib.linux-x86_64-2.7/shadowsocks\ncopying shadowsocks/server.py -> build/lib.linux-x86_64-2.7/shadowsocks\ncopying shadowsocks/asyncdns.py -> build/lib.linux-x86_64-2.7/shadowsocks\ncopying shadowsocks/cryptor.py -> build/lib.linux-x86_64-2.7/shadowsocks\ncopying shadowsocks/manager.py -> build/lib.linux-x86_64-2.7/shadowsocks\ncopying shadowsocks/__init__.py -> build/lib.linux-x86_64-2.7/shadowsocks\ncopying shadowsocks/tcprelay.py -> build/lib.linux-x86_64-2.7/shadowsocks\ncopying shadowsocks/tunnel.py -> build/lib.linux-x86_64-2.7/shadowsocks\ncopying shadowsocks/daemon.py -> build/lib.linux-x86_64-2.7/shadowsocks\ncreating build/lib.linux-x86_64-2.7/shadowsocks/crypto\ncopying shadowsocks/crypto/openssl.py -> build/lib.linux-x86_64-2.7/shadowsocks/crypto\ncopying shadowsocks/crypto/aead.py -> build/lib.linux-x86_64-2.7/shadowsocks/crypto\ncopying shadowsocks/crypto/hkdf.py -> build/lib.linux-x86_64-2.7/shadowsocks/crypto\ncopying shadowsocks/crypto/__init__.py -> build/lib.linux-x86_64-2.7/shadowsocks/crypto\ncopying shadowsocks/crypto/rc4_md5.py -> build/lib.linux-x86_64-2.7/shadowsocks/crypto\ncopying shadowsocks/crypto/sodium.py -> build/lib.linux-x86_64-2.7/shadowsocks/crypto\ncopying shadowsocks/crypto/util.py -> build/lib.linux-x86_64-2.7/shadowsocks/crypto\ncopying shadowsocks/crypto/mbedtls.py -> build/lib.linux-x86_64-2.7/shadowsocks/crypto\ncopying shadowsocks/crypto/table.py -> build/lib.linux-x86_64-2.7/shadowsocks/crypto\ncreating build/bdist.linux-x86_64\ncreating build/bdist.linux-x86_64/egg\ncreating build/bdist.linux-x86_64/egg/shadowsocks\ncopying build/lib.linux-x86_64-2.7/shadowsocks/lru_cache.py -> build/bdist.linux-x86_64/egg/shadowsocks\ncopying build/lib.linux-x86_64-2.7/shadowsocks/udprelay.py -> build/bdist.linux-x86_64/egg/shadowsocks\ncopying build/lib.linux-x86_64-2.7/shadowsocks/eventloop.py -> build/bdist.linux-x86_64/egg/shadowsocks\ncopying build/lib.linux-x86_64-2.7/shadowsocks/common.py -> build/bdist.linux-x86_64/egg/shadowsocks\ncopying build/lib.linux-x86_64-2.7/shadowsocks/shell.py -> build/bdist.linux-x86_64/egg/shadowsocks\ncopying build/lib.linux-x86_64-2.7/shadowsocks/local.py -> build/bdist.linux-x86_64/egg/shadowsocks\ncopying build/lib.linux-x86_64-2.7/shadowsocks/server.py -> build/bdist.linux-x86_64/egg/shadowsocks\ncreating build/bdist.linux-x86_64/egg/shadowsocks/crypto\ncopying build/lib.linux-x86_64-2.7/shadowsocks/crypto/openssl.py -> build/bdist.linux-x86_64/egg/shadowsocks/crypto\ncopying build/lib.linux-x86_64-2.7/shadowsocks/crypto/aead.py -> build/bdist.linux-x86_64/egg/shadowsocks/crypto\ncopying build/lib.linux-x86_64-2.7/shadowsocks/crypto/hkdf.py -> build/bdist.linux-x86_64/egg/shadowsocks/crypto\ncopying build/lib.linux-x86_64-2.7/shadowsocks/crypto/__init__.py -> build/bdist.linux-x86_64/egg/shadowsocks/crypto\ncopying build/lib.linux-x86_64-2.7/shadowsocks/crypto/rc4_md5.py -> build/bdist.linux-x86_64/egg/shadowsocks/crypto\ncopying build/lib.linux-x86_64-2.7/shadowsocks/crypto/sodium.py -> build/bdist.linux-x86_64/egg/shadowsocks/crypto\ncopying build/lib.linux-x86_64-2.7/shadowsocks/crypto/util.py -> build/bdist.linux-x86_64/egg/shadowsocks/crypto\ncopying build/lib.linux-x86_64-2.7/shadowsocks/crypto/mbedtls.py -> build/bdist.linux-x86_64/egg/shadowsocks/crypto\ncopying build/lib.linux-x86_64-2.7/shadowsocks/crypto/table.py -> build/bdist.linux-x86_64/egg/shadowsocks/crypto\ncopying build/lib.linux-x86_64-2.7/shadowsocks/asyncdns.py -> build/bdist.linux-x86_64/egg/shadowsocks\ncopying build/lib.linux-x86_64-2.7/shadowsocks/cryptor.py -> build/bdist.linux-x86_64/egg/shadowsocks\ncopying build/lib.linux-x86_64-2.7/shadowsocks/manager.py -> build/bdist.linux-x86_64/egg/shadowsocks\ncopying build/lib.linux-x86_64-2.7/shadowsocks/__init__.py -> build/bdist.linux-x86_64/egg/shadowsocks\ncopying build/lib.linux-x86_64-2.7/shadowsocks/tcprelay.py -> build/bdist.linux-x86_64/egg/shadowsocks\ncopying build/lib.linux-x86_64-2.7/shadowsocks/tunnel.py -> build/bdist.linux-x86_64/egg/shadowsocks\ncopying build/lib.linux-x86_64-2.7/shadowsocks/daemon.py -> build/bdist.linux-x86_64/egg/shadowsocks\nbyte-compiling build/bdist.linux-x86_64/egg/shadowsocks/lru_cache.py to lru_cache.pyc\nbyte-compiling build/bdist.linux-x86_64/egg/shadowsocks/udprelay.py to udprelay.pyc\nbyte-compiling build/bdist.linux-x86_64/egg/shadowsocks/eventloop.py to eventloop.pyc\nbyte-compiling build/bdist.linux-x86_64/egg/shadowsocks/common.py to common.pyc\nbyte-compiling build/bdist.linux-x86_64/egg/shadowsocks/shell.py to shell.pyc\nbyte-compiling build/bdist.linux-x86_64/egg/shadowsocks/local.py to local.pyc\nbyte-compiling build/bdist.linux-x86_64/egg/shadowsocks/server.py to server.pyc\nbyte-compiling build/bdist.linux-x86_64/egg/shadowsocks/crypto/openssl.py to openssl.pyc\nbyte-compiling build/bdist.linux-x86_64/egg/shadowsocks/crypto/aead.py to aead.pyc\nbyte-compiling build/bdist.linux-x86_64/egg/shadowsocks/crypto/hkdf.py to hkdf.pyc\nbyte-compiling build/bdist.linux-x86_64/egg/shadowsocks/crypto/__init__.py to __init__.pyc\nbyte-compiling build/bdist.linux-x86_64/egg/shadowsocks/crypto/rc4_md5.py to rc4_md5.pyc\nbyte-compiling build/bdist.linux-x86_64/egg/shadowsocks/crypto/sodium.py to sodium.pyc\nbyte-compiling build/bdist.linux-x86_64/egg/shadowsocks/crypto/util.py to util.pyc\nbyte-compiling build/bdist.linux-x86_64/egg/shadowsocks/crypto/mbedtls.py to mbedtls.pyc\nbyte-compiling build/bdist.linux-x86_64/egg/shadowsocks/crypto/table.py to table.pyc\nbyte-compiling build/bdist.linux-x86_64/egg/shadowsocks/asyncdns.py to asyncdns.pyc\nbyte-compiling build/bdist.linux-x86_64/egg/shadowsocks/cryptor.py to cryptor.pyc\nbyte-compiling build/bdist.linux-x86_64/egg/shadowsocks/manager.py to manager.pyc\nbyte-compiling build/bdist.linux-x86_64/egg/shadowsocks/__init__.py to __init__.pyc\nbyte-compiling build/bdist.linux-x86_64/egg/shadowsocks/tcprelay.py to tcprelay.pyc\nbyte-compiling build/bdist.linux-x86_64/egg/shadowsocks/tunnel.py to tunnel.pyc\nbyte-compiling build/bdist.linux-x86_64/egg/shadowsocks/daemon.py to daemon.pyc\ncreating build/bdist.linux-x86_64/egg/EGG-INFO\ncopying shadowsocks.egg-info/PKG-INFO -> build/bdist.linux-x86_64/egg/EGG-INFO\ncopying shadowsocks.egg-info/SOURCES.txt -> build/bdist.linux-x86_64/egg/EGG-INFO\ncopying shadowsocks.egg-info/dependency_links.txt -> build/bdist.linux-x86_64/egg/EGG-INFO\ncopying shadowsocks.egg-info/entry_points.txt -> build/bdist.linux-x86_64/egg/EGG-INFO\ncopying shadowsocks.egg-info/top_level.txt -> build/bdist.linux-x86_64/egg/EGG-INFO\nzip_safe flag not set; analyzing archive contents...\nshadowsocks.tunnel: module references __file__\nshadowsocks.shell: module references __file__\nshadowsocks.server: module references __file__\nshadowsocks.local: module references __file__\ncreating dist\ncreating 'dist/shadowsocks-3.0.0-py2.7.egg' and adding 'build/bdist.linux-x86_64/egg' to it\nremoving 'build/bdist.linux-x86_64/egg' (and everything under it)\nProcessing shadowsocks-3.0.0-py2.7.egg\nremoving '/usr/local/lib/python2.7/dist-packages/shadowsocks-3.0.0-py2.7.egg' (and everything under it)\ncreating /usr/local/lib/python2.7/dist-packages/shadowsocks-3.0.0-py2.7.egg\nExtracting shadowsocks-3.0.0-py2.7.egg to /usr/local/lib/python2.7/dist-packages\nshadowsocks 3.0.0 is already the active version in easy-install.pth\nInstalling sslocal script to /usr/local/bin\nInstalling ssserver script to /usr/local/bin\n\nInstalled /usr/local/lib/python2.7/dist-packages/shadowsocks-3.0.0-py2.7.egg\nProcessing dependencies for shadowsocks==3.0.0\nFinished processing dependencies for shadowsocks==3.0.0\nwriting list of installed files to '/usr/local/shadowsocks_install.log'\nINFO: loading config from /etc/shadowsocks.json\n2018-03-30 08:00:27 INFO     loading libcrypto from libcrypto.so.1.0.0\nStarting Shadowsocks success\n\nCongratulations, Shadowsocks-python server install completed!\nYour Server IP        :  xxx.xxx.xxx.xxx\nYour Server Port      :  xxx\nYour Password         :  xxx\nYour Encryption Method:  aes-256-cfb\n\nWelcome to visit:https://teddysun.com/342.html\nEnjoy it!\n```\n2、启动ss\n\n```\n\tssserver -c /etc/shadowsocks.json -d start\n```\n停止ss服务：\n```\n\tssserver -c /etc/shadowsocks.json -d stop\n```\n3、配置多用户，增加端口\n```\n\t同Centos 6\n```\n4、开放防火墙端口\n新增加的端口防火墙是没有开放的，需要手动开放\n```\n\tvi /etc/firewalld/zones/public.xml\n```\n将端口8888的两行配置复制一下到下面，将其修改为9999。以开放9999端口的TCP和UDP访问功能。 配置完成后需要重启SS和刷新防火墙配置，执行：\n```\n  /etc/init.d/shadowsocks restart\n  firewall-cmd --reload\n```\n最后本机ss客户端填写配置信息，然后尝试访问谷歌，测试一下每个端口是否都可用，如果都可用，说明配置正确。\n\n### 二、搭建锐速\n1、对于centos7，内核更换为： 3.10.0-229.1.2.el7.x86_64\n```\nrpm -ivh http://soft.91yun.org/ISO/Linux/CentOS/kernel/kernel-3.10.0-229.1.2.el7.x86_64.rpm --force\n```\n2、更换内核后重启服务器\n```\nsystemctl reboot\n```\n3、安装锐速，这里我们仍然使用一键脚本\n```\nwget -N --no-check-certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder-all.sh && bash serverspeeder-all.sh\n```\n4、启动锐速\n```\nservice serverSpeeder start\n```\n至此就搭建完啦，试着打开youtube看看1080p的视频吧，速度是不是挺给力？如果是，那么恭喜你，搭建成功了！\n","tags":["上网工具","translate"]},{"title":"检测对象是否是json","url":"/2020/06/02/检测对象是否是json/","content":"检测一个对象是否是一个对象的方法：\n\n```\nif(typeof(obj) == \"object\" && Object.prototype.toString.call(obj).toLowerCase() == \"[object object]\" && !obj.length){\n\talert('是JSON对象');\n}\n```\n\n<!-- more -->\n","tags":["util"]},{"title":"未来很美好","url":"/2020/06/02/未来很美好/","content":"### 新奇教程\n[![tYrjX9.jpg](https://s1.ax1x.com/2020/06/02/tYrjX9.jpg)](https://imgchr.com/i/tYrjX9)\n\n谷歌的一个 AI 试验，用户对着摄像头做出指挥的动作，谷歌会识别动作，然后配上乐队的音乐。\n- https://woodgears.ca/tech/heater_aimer.html\n<!-- more -->\n在线游戏 文明\n- https://github.com/freeciv/freeciv-web\n","tags":["杂记"],"categories":["percetion"]},{"title":"记录Hexo + Next 新增导航并添加文章","url":"/2020/06/01/记录Hexo-Next-新增导航并添加文章/","content":"## 1、新建导航/菜单\n执行以下命令:\n```hexo\n  hexo new page '导航/菜单名称'\n```\n执行之后 开启预览会有新建的菜单 `导航/菜单名称`\n<!-- more -->\n## 2、修改主题菜单/导航配置\n  1. 打开 `hexo/_config.yml` 文件，找到 `language:`，这行代码。例如我的语言是 `language: zh-CN` 。\n  2. 打开文件 `hexo/themes/next/language`（`next`主题，打开你当前主题里的 `language` 文件夹）。那么我就打开 `language/zh-CN.yml`，与你的语言对应的文件。\n  3. 在 Menu: 下方添加一行 `导航/菜单 英文 : 导航/菜单 中文`，就修改成 `导航/菜单 中文`了。\n  4. 打开新建菜单文件下的 `index.md` ，修改成 `title: 写成你想要的名字`  即可（可省略）。\n\n## 3、实现新建导航下多篇文章（这里用到的办法借用了 categories 的分类功能，其实就是将某个分类移到了左侧菜单上）\n  1. 我们在 `_post` 目录下有几篇文章想放到该菜单下，我们给这些文章分类为 `categories: - 新建导航/菜单 的英文` 。\n  2. 打开 `hexo/themes/next/_config.yml` 文件，找到 `menu:`，添加一行 `新建导航/菜单 的英文: //categories/ '新建导航/菜单 的英文' / || icon的名称(可以参照 home 项更改)` 即可。\n  3. 这时我们点击，该菜单，就会发现里面可以显示这几篇文章。\n","tags":["skill","add article"],"categories":["skill"]},{"title":"First Blog","url":"/2020/05/27/First-Blog/","content":"\n利用 `github` 的二级域名搭建个人博客（默认已经拥有了`node`, `git`, `github`）等基础要求；\n\n### 1、github 构建新仓库\n\n构建新仓库注意 构建的这个博客仓库具有唯一性 所以名称格式为 username.github.io\n<!-- more -->\n### 2、生成本地 ssh\n\n```git\n    ssh-keygen -t rsa -C 'github账号'\n```\n生成的 ssh 信息 默认为 用户/当前账户/.ssh/id_rsa.pub 文件内 可以用记事本打开\n\nMAC 查看 SSH 信息命令如下：\n```bash\n    cat ~/.ssh/id_rsa.pub\n```\n返回以 `ssh-rsa` 开头的 ssh 秘钥\n\n### 3、生成 ssh 保存到 github\n\n右上角个人信息 -> settings -> SSH and GPG keys -> new SSH key 填入上一步生成的 ssh 信息\n\n测试 ssh  和本地是否连通\n```git\n$ ssh -T git@github.com\n```\n回车 输入`yes`\n果看到Hi后面是你的用户名，就说明成功了\n\n\n### 4、本地安装 hexo 主题\n\n```npm\n    npm install hexo -g\n```\n修改配置信息 打开 `_congfig.yml` 文件 修改 `deploy`\n```\n    deploy:\n        type: git\n        repo: git@github.com:username/username.github.io.git\n        branch: master\n```\n\n### 5、设置本地账户信息\n\n```git\n    $ git config --global user.name \"yourname\"\n    $ git config --global user.email youeremail@example.com\n```\n\n### 6、执行命令\n生成静态文件\n```git\n    hexo g  // 生成文件\n```\n预览静态文件\n```git\n    hexo s  // 预览静态文件 访问localhost:4000\n```\n发布到远程仓库\n```git\n    hexo d\n```\n这一步默认会报错 提示没有git 错误： `Deployer not found: git`\n**解决办法：**\n```npm\n    npm install hexo-deployer-git --save\n```\n然后再次执行\n```\n    hexo d\n```\n即可发布到远程仓库\n最后可以通过 `yourname.github.io` 访问博客\n\n\n","tags":["blog,learn"]}]